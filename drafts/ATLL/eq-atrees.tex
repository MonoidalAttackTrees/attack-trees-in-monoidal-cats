Jhawar et al.~\cite{Jhawar:2015} characterize equivalence of n-ary
attack trees by the following definition.
\begin{definition}
  \label{def:jhawar-eq-atrees}
  The following rules define equivalence of n-ary attack trees over a
  set of base attacks $\mathbb{B}$:
  \begin{center}
    \begin{math}
      \begin{array}{llcl}
        (E_1) & [[OR]]([[A1]], \ldots, [[A]]_i,[[A]]_{i+1},\ldots,[[Aj]])  & = & [[OR]]([[A1]], \ldots, [[A]]_{i+1},[[A]]_i,\ldots,[[Aj]])\\
        (E_2) & [[AND]]([[A1]], \ldots, [[A]]_i,[[A]]_{i+1},\ldots,[[Aj]]) & = & [[AND]]([[A1]], \ldots, [[A]]_{i+1},[[A]]_i,\ldots,[[Aj]])\\
        (E_3) & [[OR]](\overrightarrow{A},[[OR]](\overrightarrow{B})) & = & [[OR]](\overrightarrow{A},\overrightarrow{B})\\
        (E_4) & [[AND]](\overrightarrow{A},[[AND]](\overrightarrow{B})) & = & [[AND]](\overrightarrow{A},\overrightarrow{B})\\
        (E_{4'}) & [[SAND]](\overrightarrow{A},[[SAND]](\overrightarrow{B}),\overrightarrow{C}) & = & [[SAND]](\overrightarrow{A},\overrightarrow{B},\overrightarrow{C})\\
        (E_5) & [[OR]](A) & = & A\\
        (E_6) & [[AND]](A) & = & A\\
        (E_{6'}) & [[SAND]](A) & = & A\\
        (E_{10}) & [[AND]](\overrightarrow{A},[[OR]](\overrightarrow{B})) & = & [[OR]]([[AND]](\overrightarrow{[[A]]},[[B1]]),\ldots,[[AND]](\overrightarrow{[[A]]},[[Bi]]))\\
        (E_{10'}) & [[SAND]](\overrightarrow{A},[[OR]](\overrightarrow{B}),\overrightarrow{C}) & = & [[OR]]([[SAND]](\overrightarrow{[[A]]},[[B1]],\overrightarrow{C}),\ldots,[[SAND]](\overrightarrow{[[A]]},[[Bi]],\overrightarrow{C}))\\
        (E_{11}) & [[OR]](A,A,\overrightarrow{B}) & = & [[OR]](A,\overrightarrow{B})
      \end{array}
    \end{math}
  \end{center}
\end{definition}
They then proceed to attempt to define a procedure for determining
when two attack trees are equivalent by first orienting each rule,
except rules $E_1$ and $E_2$, by treating them as left-to-write
rewrite rules.  Then equality of two attack trees, say $[[A]]$ and
$[[B]]$, can be determined by first rewriting $[[A]]$ and $[[B]]$ into
normal forms, and then comparing the normal forms.  However, before
such a procedure can be used they must prove confluence and uniqueness
of normal forms with respect to the rewrite system.  Finally, to
obtain confluence they use the well-known method of proving the term
rewrite system terminating and that it has uniqueness of normal forms.

However, despite their proof attempt uniqueness of normal forms fails
for this particular rewriting system.  Suppose $[[b1]]$ and $[[b2]]$
are two base attacks.  Then the following is a counter example to
uniqueness of normal forms:
\begin{center}
  \begin{math}
    \begin{array}{lll}
      [[OR]]([[b1]],[[b2]])
      \leftsquigarrow
      [[OR]]([[OR]]([[b1]],[[b2]]),[[OR]]([[b1]],[[b2]]))
      \rightsquigarrow
          [[OR]]([[OR]]([[b1]],[[b2]]),[[b1]],[[b2]])
    \end{array}
  \end{math}
\end{center}
First, $[[OR]]([[b1]],[[b2]])$ is irreducible, if we had symmetry then
we could reduce \\ $[[OR]]([[OR]]([[b1]],[[b2]]),[[b1]],[[b2]])$ to
$[[OR]]([[b1]],[[b2]])$, using symmetry, $E_3$, and $E_{11}$, but
symmetry is not part of this rewrite system, and $E_3$ does not apply,
because it requires the $[[OR]]$ to be last in the sequence of inputs.
Therefore, $[[OR]]([[OR]]([[b1]],[[b2]]),[[b1]],[[b2]])$ is
irreducible.  There are other counterexamples as well.  

There are a few problems with the definition of the equations.  They
are built with symmetry in mind, and so orienting the equations into
left-to-right rewrite rules without symmetry induces these types of
counterexamples.  Secondly, unconstrained contraction, rule $E_{11}$,
can also be very problematic.

We now repair their definition throughout the remainder of this
section.  Instead of starting with equations and moving to a rewrite
system we being the other way around.  In addition, we simplify the
situation by, without loss of generality, only considering binary
attack trees instead of n-ary attack trees.  The n-ary case can be
embedded into the binary case, and the binary case has a nice
interpretation into our later models.  In fact, throughout the rest of
the paper we only consider the binary case unless otherwise explicitly
stated.

The main idea behind our approach is the realization that contraction
can be isolated and used to remove all points of contraction from an
attack tree, and then continuing to rewrite without contraction.  This
also makes the analysis of the rewrite systems easier. The following
defines the contraction rewrite system.
\begin{definition}
  \label{def:contraction-rw}
  The following inference rules define a rewrite system, $[[A ~>c
      B]]$, between attack trees that primarily removes contractions:
  \begin{center} \small \vspace{-15px}
    \begin{mathpar}
      \ATermsdruleCXXct{} \and \ATermsdruleCXXassoc{} \and
      \ATermsdruleCXXorOne{} \and \ATermsdruleCXXorTwo{} \and
      \ATermsdruleCXXandOne{} \and \ATermsdruleCXXandTwo{} \and
      \ATermsdruleCXXsandOne{} \and \ATermsdruleCXXsandTwo{} \and
    \end{mathpar}
  \end{center}
\end{definition}
The most important aspect of the previous rewrite system is that they
enforce a particular rewrite strategy.  If the contraction rule,
$\copyright$, applies, then it must be used before using any other
$[[OR]]$ rule.  This removes the critical pair given above.  We denote
by $[[A ~>c* B]]$ the reflexive and transitive closure of $[[A ~>c
    B]]$.

We say an attack tree, $[[A]]$, is in \emph{contractive normal form}
if there is no subtree of $[[A]]$ matching $[[OR B B]]$ for some
attack tree $[[B]]$.  The following shows that the above rewrite
system can be used to rewrite away all contractions within an attack
tree.
\begin{lemma}[Contractive Weak Normalization]
  \label{lemma:contractive_weak_normalizatino}
  Suppose $[[A]]$ is an attack tree over a set of base attacks
  $\mathbb{B}$.  Then there is a contractive normal form, $T$, such
  that, $[[A ~>c* T]]$.
\end{lemma}
\begin{proof}
  This proof holds by induction on the structure of $[[A]]$.
  \begin{itemize}
  \item Suppose $[[A]] = [[OR(A1,A2)]]$.  If $[[A1]] = [[A2]]$, then
    by the induction hypothesis there is a contractive normal form
    $[[T1]]$ such that $[[A1 ~>c* T1]]$.  Then choose $[[T]] =
    [[T1]]$, and our result follows by rewriting $[[A]] =
    [[OR(A1,A2)]] [[~>c]] [[A1]] [[~>c*]] [[T1]] = [[T]]$.

    \ \\
    \noindent
    Suppose $[[A1 != A2]]$.  Then by the induction hypothesis there
    are contractive normal forms $[[T1]]$ and $[[T2]]$, such that,
    $[[A1]] [[~>c*]] [[T1]]$ and $[[A2]] [[~>c*]] [[T2]]$.
    
    \ \\
    \noindent
    Suppose $[[A1 != A2]]$.  Then by the induction hypothesis there
    are contractive normal forms $[[T1]]$ and $[[T2]]$ such that $[[A1
        ~>c* T1]]$ and $[[A2 ~>c* T2]]$.  At this point we have a
    choice to make.  During rewriting if a contraction point is ever
    introduced, then it must be contracted, thus, we do not necessarily
    know at this point that $[[OR(A1,A2) ~>c* OR(T1,T2)]]$, because,
    for example, $[[T1]]$ could be equal to $[[A2]]$, and at that
    point a contraction must be made.  So if $[[T1]] = [[A2]]$, then
    $[[A]] = [[OR(A1,A2)]] [[~>c*]] [[OR(T1,A2)]] [[~>c]] [[T1]]$, so
    choose $[[T]] = [[T1]]$ and we obtain our result. The case is
    similar if $[[A2]] = [[T2]]$. So now suppose $[[T1 != A2]]$ and
    $[[T2 != A1]]$.  Then $[[A]] = [[OR(A1,A2)]] [[~>c*]]
    [[OR(T1,T2)]]$.  If $[[T1]] = [[T2]]$, then choose $[[T]] =
    [[T1]]$ and $[[A]] = [[OR(A1,A2)]] [[~>c*]] [[OR(T1,T2)]] [[~>c]]
    [[T1]] = [[T2]]$, otherwise choose $[[T]] = [[OR(T1,T2)]]$ and we
    obtain our result.

  \item Suppose $[[A]] = [[AND(A1,A2)]]$. By the induction hypothesis
    there are contractive normal forms $[[T1]]$ and $[[T2]]$ such that
    $[[A1 ~>c* T1]]$ and $[[A2 ~>c* T2]]$.  Thus, choose $[[T]] =
    [[AND(T1,T2)]]$ and we obtain our result.

  \item Suppose $[[A]] = [[SAND(A1,A2)]]$. Similar to the previous
    case.
  \end{itemize}
\end{proof}
