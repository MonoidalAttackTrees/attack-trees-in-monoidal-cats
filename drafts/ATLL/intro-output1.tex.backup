%% - Better understanding the theory of attack trees
%% - Specializations using implication
%% - Lina!!
Attack trees are perhaps the most popular graphical model used to
conduct threat analysis of both physical and virtual secure
systems. They were made popular by Bruce Schneier in the late nineties
\cite{Schneier:1999}.  In those early years attack trees were studied
and used as a syntactic tool to help guide analysis.  However, as
systems grew more complex the need for a semantics of attack trees
become apparent, after all, without a proper semantics how can we
safely manipulate attack trees, extend the expressivity of attack
trees, or compare them?

A number of different models of attack trees have been proposed: a
model in boolean algebras
\cite{Kordy:2014,Kordy:2012,Pietre-Cambacedes:2010}, series-parallel
pomsets \cite{Mauw:2006}, Petri nets \cite{McDermott:2001}, and tree
automata \cite{Camtepe:2007}.  There have also been various
extensions, such as, adding sequential composition \cite{Jhawar:2015},
and defense nodes \cite{Kordy:2011,Kordy:2012}.  All of these models
and extensions have their benefits, but at the heart of them all is
logic.

The model in boolean algebras was the first and most elegant model of
attack trees, but it failed to capture the process notion of attack
trees, that is, the fact that base attacks are actual processes that
need to be carried out, and the branching nodes composed these
processes in different ways.  Thus, the community moved towards models
of resources like parallel-series pomsets, Petri nets, and automata.
However, the complexity of these models increased, and hence,
comparing the models is difficult which makes it hard to decide which
to use and under which circumstances, and so we have wondered, is
there a means of recovering the elegant model in logic, and can this
logic teach us anything new?

\textbf{Linear Logic.}  It is fitting that attack trees are the most
popular model used in threat analysis, because one of the most widely
studied logics used to reason about resources is \emph{linear logic}
which is an excellent candidate for modeling attack trees.  In fact,
Horne et al.\cite{horne2017semantics} has already produced a number of
interesting results.  Most importantly, they show that attack trees
can be modeled as formulas in linear logic, and then one can prove
properties between attack trees by proving implications between them.
Furthermore, by studying attack trees from a linear logical
perspective they introduce a new property between attack trees called
\emph{specializations}.  Prior to their paper the literature was
primarily concerned with equality between attack trees, but
implication allows us to break that equality up.  A specialization is
a one way relationship between two attack trees that may even be
influenced by the attack trees attribute domain; we will discuss
specializations in more detail in Section~\ref{}.

This paper has two main contributions, the first is a new simple
linear logical semantics of causal attack trees -- attack trees with
sequential composition -- in four-valued truth tables.  We show that
our semantics is surprisingly expressive.  It supports
specializations, and even lays outside of the semantics proposed by
Horne et al.\cite{horne2017semantics}, because it combines in an
interesting way what they call the \emph{ideal} and \emph{filter}
semantics of causal attack trees.  However, the most appealing aspect
of this semantics is that it is extremely simple.  Furthermore, we
introduce a family of natural deduction systems based in the logic of
bunched implications which were formed by studying the truth table
semantics.

\textbf{Functional Programming.} Our second contribution is Lina, a
new domain specific functional programming language for conducting
threat analysis using attack trees.  Consider the example attack trees
in Fig.~\ref{fig:atm-tree1}.
\begin{figure}  
  \begin{tabular}{|l|l|}
    \hline
    \begin{tabular}{l}
      \textbf{A.}\\
    \hspace{-0.35in}
    \begin{minipage}{2.5in}        
    \begin{minted}[fontsize=\footnotesize]{haskell}
      seq_node "ATM attack"
       (and_node "get credientials"
         (base_na "steal card")
         (or_node "get PIN"
          (base_na "social engineer")
          (base_na "find a post-it")))
       (base_na "withdraw money")
    \end{minted}
    \vspace{33px}
    \end{minipage}
    \end{tabular}
    &
    \begin{tabular}{l}
      \textbf{B.}\\
      \begin{minipage}{2.5in}
      \begin{minted}[fontsize=\footnotesize]{haskell}
  or_node "ATM attack"
   (seq_node "attack vector 1"
      (and_node "get credentials 1"
         (base_na "social engineer")
         (base_na "steal card"))
      (base_na "withdraw money"))
   (seq_node "attack vector 2"
      (and_node "get credentials 2"
         (base_na "steal card")
         (base_na "find a post-it"))
      (base_na "withdraw money"))      
      \end{minted}
    \end{minipage}
    \end{tabular}\\
    \hline
  \end{tabular}  
  \label{fig:atm-tree1}
  \caption{Attack Tree for an ATM attack from Figure~1 (A) and Figure~2 (B) of Kordy et al.~\cite{Kordy2017}}
\end{figure}
Both of these are actual Lina programs, in fact every example in this
paper are Lina programs. Lina supports causal attack trees both with
attributes or without, thus, there are two types of base attacks:
\underline{base} attacks \underline{w}ith \underline{a}ttributes,
denoted \verb!base_wa!, and \underline{base} attacks \text{w}ith
\underline{n}o \underline{a}ttributes, denoted \verb!base_na!.  Lina
is designed to be extremely simple, and actually reflect the typical
pseudocode found throughout the literature.  However, Lina is more
than just a simple definitional language.

Lina is an embedded domain specific language whose host language is
the Haskell programming language \cite{jones2003haskell}.  So, why
purely functional and why strongly typed?  As security
researchers/professionals we are in the business of verifying the
correctness of various systems. Thus, our tools should be taking
advantage of verification tools to insure that our constructions,
tools, and analysis are correct.  By embedding Lina into Haskell we
are able to take advantage of cutting edge verification tools while
conducting threat analysis.  For example, right out the box Lina
supports using property-based randomized testing using QuickCheck
\cite{Claessen:2011:QLT:1988042.1988046}, and refinement types in
Liquid Haskell \cite{Vazou:2014:RTH:2692915.2628161} to verify
properties of our attack trees or the attribute domains used while
analyzing attack trees.  Furthermore, strong typing helps catch bugs
while we develop our attack trees and their attribute domains as a
side-effect of type checking.  Finally, functional programs are short,
but not obfuscated, and hence, allow for very compact and trustworthy
programs.

That being said, we are designing Lina so that it can be used with
very little Haskell experience.  It is our hope that one will be able
to make use of Lina without having to know how to write Haskell
programs, and we plan to develop new tooling to support this.

Lina is approaching threat analysis from a programming language
perspective.  This approach leads to a number of new advances.  First,
as Gadyatskaya and Trujillo-Rasua \cite{10.1007/978-3-319-74860-3_9}
argue as a community we need to start building more automated means of
conducting threat analysis, and there is no better way to build or
connect automated tools than a programming language.  Lina is perfect
as a target for new tools, and it can be connected to existing tools
fairly easily.  In fact, Lina already supports automation using the
automatic rewrite system Maude \cite{clavel2005maude}, for example,
the two attack trees in Fig.~\ref{fig:atm-tree1} can be automatically
proven equivalent to each other in Lina.  This is similar to Krody's
\cite{Kordy2017} SPTool, but Lina goes further and supports more than
one backend rewrite system, for example, Lina is the first tool to
support automatically proving specializations of attack trees.  The
user can choose which backend they wish to use.

We have a number of extensions planned for the future like supporting
attack-defense trees, attack(-defense) graphs, and attack nets. We
plan to support even more automation using SAT and SMT solvers.  It is
our hope that Lina grows into a one stop shop for threat analysis.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: main.tex
%%% End: 
