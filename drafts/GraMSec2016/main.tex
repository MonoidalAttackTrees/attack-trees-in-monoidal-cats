\documentclass{llncs}

\usepackage{amssymb,amsmath}
\usepackage{cmll}
\usepackage{stmaryrd}
\usepackage{todonotes}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[barr]{xy}

%% This renames Barr's \to to \mto.  This allows us to use \to for imp
%% and \mto for a inline morphism.
\let\mto\to
\let\to\relax
\newcommand{\to}{\rightarrow}

% Commands that are useful for writing about type theory and programming language design.
%% \newcommand{\case}[4]{\text{case}\ #1\ \text{of}\ #2\text{.}#3\text{,}#2\text{.}#4}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\normto}[0]{\rightsquigarrow^{!}}
\newcommand{\join}[0]{\downarrow}
\newcommand{\redto}[0]{\rightsquigarrow}
\newcommand{\nat}[0]{\mathbb{N}}
\newcommand{\fun}[2]{\lambda #1.#2}
\newcommand{\CRI}[0]{\text{CR-Norm}}
\newcommand{\CRII}[0]{\text{CR-Pres}}
\newcommand{\CRIII}[0]{\text{CR-Prog}}
\newcommand{\subexp}[0]{\sqsubseteq}
%% Must include \usepackage{mathrsfs} for this to work.
\newcommand{\powerset}[0]{\mathscr{P}}

\date{}

% Cat commands.
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\catop}[1]{\cat{#1}^{\mathsf{op}}}
\newcommand{\Hom}[3]{\mathsf{Hom}_{\cat{#1}}(#2,#3)}
\newcommand{\limp}[0]{\multimap}
\newcommand{\dial}[0]{\mathsf{Dial_3}(\mathsf{Sets})}
\newcommand{\dialSets}[1]{\mathsf{Dial_{#1}}(\mathsf{Sets})}
\newcommand{\dcSets}[1]{\mathsf{DC_{#1}}(\mathsf{Sets})}
\newcommand{\sets}[0]{\mathsf{Sets}}
\newcommand{\obj}[1]{\mathsf{Obj}(#1)}
\newcommand{\mor}[1]{\mathsf{Mor(#1)}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\lett}[0]{\mathsf{let}\,}
\newcommand{\inn}[0]{\,\mathsf{in}\,}
\newcommand{\cur}[1]{\mathsf{cur}(#1)}
\newcommand{\curi}[1]{\mathsf{cur}^{-1}(#1)}

\newenvironment{changemargin}[2]{%
  \begin{list}{}{%
    \setlength{\topsep}{0pt}%
    \setlength{\leftmargin}{#1}%
    \setlength{\rightmargin}{#2}%
    \setlength{\listparindent}{\parindent}%
    \setlength{\itemindent}{\parindent}%
    \setlength{\parsep}{\parskip}%
  }%
  \item[]}{\end{list}}

%% Ott
\input{atrees-ott}

\begin{document}

\title{Proposing a New Foundation of Attack Trees in Monoidal Categories}

\author{Harley Eades III}
\institute{Computer and Information Sciences, Augusta University, Augusta, GA, \email{heades@augusta.edu}}

\maketitle 

\begin{abstract}
  This short paper introduces a new project studying at the
  intersection of threat analysis using attack trees and interactive
  theorem proving using linear logic.  The project proposes a new
  semantics of attack trees in dialectica spaces, a well-known model
  of intuitionistic linear logic, which offers two new branching
  operators to attack trees.  Then by exploiting the
  Curry-Howard-Lambek correspondence it seeks to develop a
  domain-specific linear functional programming language called Lina
  -- for Linear Threat Analysis -- for specifying and reasoning about
  attack trees.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

What do propositional logic, multisets, directed acyclic graphs,
source sink graphs (or parallel-series pomsets), Petri nets, and
Markov processes all have in common?  They are all mathematical models
of attack trees -- see the references in
\cite{Kordy:2014a,Jhawar:2015} -- but also, they can all be modeled in
some form of a symmetric monoidal category\footnote{I provide a proof
  that the category of source sink graphs is monoidal in
  Appendix~\ref{sec:source_sink_graphs_are_symmetric_monoidal}.}
\cite{Tzouvaras:1998,Brown:1991,Fiore:2013,FrancescoAlbasini2010} --
for the definition of a symmetric monoidal category see
Appendix~\ref{sec:symmetric_monoidal_categories}.  Taking things a
little bit further, monoidal categories have a tight correspondence
with linear logic through the beautiful Curry-Howard-Lambek
correspondence \cite{MSC:4439568}.  This correspondence states that
objects of a monoidal category correspond to the formulas of linear
logic and the morphisms correspond to proofs of valid sequents of the
logic.  I propose that attack trees -- in many different flavors -- be
modeled as objects in monoidal categories, and hence, as formulas of
linear logic.

The Curry-Howard-Lambek correspondence is a three way relationship:
\begin{center}
  \footnotesize
  \setlength{\tabcolsep}{7pt}
  \begin{tabular}{ccccc}
    Categories & $\iff$ & Logic    & $\iff$   & Functional Programming\\
    Objects    & $\iff$ & Formulas & $\iff$   & Types    \\
    Morphisms  & $\iff$ & Proofs   & $\iff$   & Programs 
  \end{tabular}
\end{center}
By modeling attack trees in monoidal categories we obtain a sound
mathematical model, a logic for reasoning about attack trees, and the
means of constructing a functional programming language for defining
attack trees (as types), and constructing semantically valid
transformations (as programs) of attack trees.  

Linear logic was first proposed by Girard \cite{Girard:1987} and was
quickly realized to be a theory of resources.  In linear logic, every
hypothesis must be used exactly once.  Thus, formulas like $A \otimes
A$ and $A$ are not logically equivalent -- here $\otimes$ is linear
conjunction.  This resource perspective of linear logic has been very
fruitful in computer science and lead to linear logic being a logical
foundation of processes and concurrency where formulas may be
considered as processes.  Treating attack trees as concurrent
processes is not new; they have been modeled by event-based models of
concurrency like Petri nets and partially-ordered multisets (pomsets)
\cite{Jhawar:2015,Mauw:2006}.  In fact, pomsets is a model in which
events (the resources) can be executed exactly once, and thus, has a
relationship with linear logic \cite{Retore:1997}.  However,
connecting linear logic as a theory of attack trees is novel, and
strengthens this perspective.

Girard's genius behind linear logic was that he isolated the
structural rules -- weakening and contraction -- by treating them as
an effect and putting them inside a comonad called the of-course
exponential denoted $!A$.  In fact, $!A \otimes !A$ is logically
equivalent to $!A$, and thus, by staying in the comonad we become
propositional.  This implies that a model of attack trees in linear
logic also provides a model of attack trees in propositional logic,
and a combination of the two.  It is possible to have the best of both
worlds.

In this short paper I introduce a newly funded research
project\footnote{This material is based upon work supported by the
  National Science Foundation CRII CISE Research Initiation grant,
  ``CRII:SHF: A New Foundation for Attack Trees Based on Monoidal
  Categories``, under Grant No. 1565557.}  investigating founding
attack trees in monoidal categories, and through the
Curry-Howard-Lambek correspondence deriving a new domain-specific
functional programming language called Lina for Linear Threat
Analysis.  I begin by defining an extension -- inspired by our
semantics -- of the attack trees given in \cite{Jhawar:2015} in
Section~\ref{sec:attack_trees}.  Then I introduce a new semantics of
attack trees in dialectica spaces, which depends on a novel result on
dialectica spaces, in
Section~\ref{sec:concrete_semantics_of_attack_trees_in_dialectica_spaces}.
The final section,
Section~\ref{sec:lina:_a_domain_specific_pl_for_threat_analysis},
discusses Lina and some of the current problems the project seeks to
answer.
% section introduction (end)

\section{Attack Trees}
\label{sec:attack_trees}
In this paper I consider an extension of attack trees with sequential
composition which are due to Jhawar et al. \cite{Jhawar:2015}, but one
of the projects ultimate goals is to extend attack trees with even
more operators driven by our choice of semantics.  The syntax for
attack trees is defined in the following definition.
\begin{definition}
  \label{def:atrees}
  The following defines the syntax of \textbf{Attack Trees} given a set
  of base attacks $b \in \mathsf{B}$:
  \[
  \begin{array}{lll}
    t ::= [[b]] \mid [[t1 + t2]] \mid [[t1 (+) t2]] \mid [[t1;t2]] \mid [[t1 (x) t2]] \mid [[! t ]]\\
  \end{array}
  \]
  I denote unsynchronized non-communicating parallel composition of
  attacks by $[[t1 + t2]]$, choice between attacks by $[[t1 (+) t2]]$,
  sequential composition of attacks by $[[t1;t2]]$, and two new
  operators called unsynchronized interacting parallel composition,
  denoted $[[t1 (x) t2]]$, and copy, denoted $[[! t]]$.

  \ \\
  \noindent
  The following rules define the attack tree reduction relation:
  \begin{center}
    \vspace{-17px}
    \footnotesize
    \begin{math}
      \begin{array}{cccccccccccc}
        \inferrule* [right={\scriptsize assoc}] {
          \,
        }{[[(t1 op t2) op t3]] \redto [[t1 op (t2 op t3)]]}
        &
        \inferrule* [right={\scriptsize sym}] {
          \,
        }{[[t1 opS t2]] \redto [[t2 opS t1]]}
        \\
        \inferrule* [right={\scriptsize copy}] {
          \,
        }{[[h(!t) (x) !t]] \redto [[!t]]}            
        &
        \inferrule* [right={\scriptsize $\textsc{dist}_1$}] {
          \,
        }{[[(t1 (+)  t2) + t]] \redto [[(t1 + t) (+) (t2 + t)]]}
        \\
        \inferrule* [right={\scriptsize $\textsc{dist}_2$}] {
          \,
        }{[[(t1 (+)  t2) ; t]] \redto [[(t1 ; t) (+) (t2 ; t)]]}
      \end{array}
    \end{math}    
  \end{center}
  where $\mathsf{op} \in \{\odot, \otimes, \rhd, \sqcup\}$ and $\mathsf{op_S}
  \in \{\odot, \otimes, \sqcup\}$.  The previous rules can be applied on
  any well-formed subattack tree, and can be straightforwardly
  extended into an equivalence relation. %% The equivalence relation, denoted
  %% $\equiv$, on attack trees is defined as the reflexive, symmetric,
  %% and transitive closure of the reduction relation $\redto$.
\end{definition}
The syntax given in the previous definition differs from the syntax
used by Jhawar et al. \cite{Jhawar:2015}.  First, I use infix binary
operations, while they use prefix $n$-ary operations. However, it does
not sacrifice any expressivity, because each operation is associative,
and parallel composition, choice, and interacting parallel composition
are symmetric.  Thus, Jhawar et al.'s definition of attack trees can
be embedded into the ones defined here.%% The hard
%% part of this embedding is realizing that the $n$-ary version of
%% sequential composition can be modeled by the binary version, but if we
%% have $\mathsf{SAND}(t_1,t_2,\ldots,t_n)$, then it is understood that
%% $t_1$ is executed, then $t_2$, and so on until $t_n$ is executed, but
%% this is exactly the same as $t_1;t_2;\cdots;t_n$.  

The second major difference is that the typical parallel composition
operator found in attack trees is modeled here by unsynchronized
non-communicating parallel composition which happens to be symmetric
tensor product, and not a disjunction.  This is contrary to the
literature, for example, the parallel operation of Jhawar et
al. defined on source sink graphs \cite{Jhawar:2015} can be proven to
be a coproduct -- see
Appendix~\ref{sec:source_sink_graphs_are_symmetric_monoidal} -- and
coproducts categorically model disjunctions.  Furthermore, parallel
composition is modeled by multiset union in the multiset semantics,
but we can model this as a coproduct.  However, in the semantics given
in the next section if we took parallel composition to be a coproduct,
then the required isomorphisms necessary to model attack trees would
not exist.

The third difference is that I denote the choice between executing
attack $[[t1]]$ or attack $[[t2]]$, but not both, by $[[t1 (+) t2]]$
instead of using a symbol that implies that it is a disjunction.  This
fits very nicely with the semantics of Jhawar et al., where they
collect the attacks that can be executed into a set.  The semantics I
give in the next section models choice directly.

The fourth, and final, difference is that I extend the syntax with two
new operators called unsynchronized communicating parallel composition
and copy.  The attack $[[t1 (x) t2]]$ states that $[[t1]]$ interacts
with the attack $[[t2]]$ in the sense that processes interact.
Modeling interacting attacks allows for the more refined modeling of
security critical systems, for example, it can be used to bring social
engineering into the analysis where someone communicates malicious
information or commands to a unsuspecting party.  As a second example,
interacting parallel composition could be used to model interacting
bot nets.

The attack $[[! t]]$ indicates that attack $[[t]]$ can be copied and
contracted.  For example, $[[h(!t) (x) !t]]$ is equivalent to $[[!
    t]]$.  Thus, the attack trees given here can treat attack trees as
processes/resources that cannot be freely copied and deleted, as
propositions that can be, and as a mixture of the two.  Semantically,
$[[! t]]$ is equivalent to the of-course exponential from linear logic
mentioned in the introduction.

The reduction rules are a slightly extended version of equivalences
given in Jhaware et al. \cite{Jhawar:2015} -- Theorem 1.  The main
difference is the $\textsc{copy}$ rule which allows copies made by the
copy operator to be contracted.
% section attack_trees (end)

\section{Semantics of Attack Trees in Dialectica Spaces}
\label{sec:concrete_semantics_of_attack_trees_in_dialectica_spaces}

I now introduce a new semantics of attack trees that connects their
study with a new perspective of attack trees that could highly impact
future research in attack trees: intuitionistic linear logic, but it
also strengthens their connection to process calculi.  This section
has been formalized in the proof assistant Agda\footnote{The complete
  formalization can be found at
  \url{https://github.com/heades/dialectica-spaces/tree/GraMSec16}
  which is part of a general library for working with dialectica
  spaces in Agda developed with Valeria de Paiva.}.  The semantics is
based on the notion of a dialectica space:

\begin{definition}
  \label{def:dialectica-space}
  A \textbf{dialectica space} is a triple $(A, Q, \delta)$ where $A$
  and $Q$ are sets and $\delta : A \times Q \to \mathsf{3}$ is a
  multi-relation where $\mathsf{3} = \{0,\perp,1\}$ and $\perp$
  represents undefined.
\end{definition}

Dialectica spaces can be seen as the intuitionistic cousin
\cite{dePaiva:2006b} of Chu spaces \cite{Pratt:1999}.  The latter have
be used extensively to study process algebra and as a model of
classical linear logic, while dialectica spaces and their morphisms
form a categorical model of intuitionistic linear logic called $\dial$
(originally due to de Paiva \cite{dePaiva:1987}); I do not introduce
dialectica space morphisms here, but the curious reader can find the
definition in the formal development. I will use the intuitions often
used when explaining Chu spaces as processes to explain dialectica
spaces as processes, but it should be known that these intuitions are
due to Pratt and Gupta \cite{Gupta:1994}.

Intuitively, a dialectica space, $(A , Q, \delta)$, can be thought of
as a process where $A$ is the set of actions the process will execute,
$Q$ is the set of states the process can enter, and for $a \in A$ and
$q \in Q$, $\delta(a , q)$ indicates whether action $a$ can be
executed in state $q$.

The interpretation of attack trees into dialectica spaces requires the
construction of each operation on dialectica spaces:
{\vspace{-10pt}\footnotesize\ \\
\begin{changemargin}{2pt}{2pt}\noindent
\textbf{Parallel Composition.} Suppose $\cat{A} = (A , Q, \alpha)$ and
$\cat{B} = (B , R , \beta)$ are two dialectica spaces.  Then we can
construct -- due to de Paiva \cite{dePaiva:2014a} -- the dialectica
space $\cat{A} \odot \cat{B} = (A \times B, Q \times R, \alpha \odot
\beta)$ where $(\alpha \odot \beta)((a,b) , (q,r)) = \alpha(a , q)
\otimes_3 \beta(b , r)$ and $\otimes_3$ is the symmetric tensor
product definable on $\mathsf{3}$\footnote{See the formal development
  for the full definition:
  \url{https://github.com/heades/dialectica-spaces/blob/GraMSec16/concrete-lineales.agda\#L328}}.
Thus, from a process perspective we can see that $\cat{A} \odot
\cat{B}$ executes actions of $\cat{A}$ and actions of $\cat{B}$ in
parallel.  Parallel composition is associative and symmetric.
\end{changemargin}

\begin{changemargin}{2pt}{2pt}\noindent
\textbf{Choice.} Suppose $\cat{A} = (A , Q, \alpha)$ and $\cat{B} = (B
, R , \beta)$ are two dialectica spaces.  Then we can construct the
dialectica space $\cat{A} \sqcup \cat{B} = (A + B, Q + R, \alpha
\sqcup \beta)$ where $(\alpha \sqcup \beta)(i , j) = \alpha(i , j)$ if
$i \in A$ and $j \in Q$, $(\alpha + \beta)(i , j) = \beta(i , j)$ if
$i \in B$ and $j \in R$, otherwise $(\alpha + \beta)(i , j) = 0$.
Thus, from a process perspective we can see that $\cat{A} \sqcup
\cat{B}$ executes either an action of $\cat{A}$ or an action of
$\cat{B}$, but not both.  Choice is symmetric and associative, but it
is not a coproduct, because it is not possible to define the
corresponding injections.  Brown et. al. show that Petri nets can be
modeled in dialectica spaces \cite{Brown:1991}, but they use the
coproduct as choice.  The operator given here is actually the
definition given for Chu spaces \cite{Gupta:1994}. If we were to use
the coproduct, then we would not be able to prove that choice
distributes over parallel composition nor over sequential
composition. As far as I am aware, this is the first time this has
been pointed out.
\end{changemargin}

\begin{changemargin}{2pt}{2pt}\noindent
\textbf{Sequential Composition.} Suppose $\cat{A} = (A , Q, \alpha)$
and $\cat{B} = (B , R , \beta)$ be two dialectica spaces.  Then we can
construct -- due to de Paiva \cite{dePaiva:2014a} -- the dialectica
space $\cat{A} \rhd \cat{B} = (A \times B, Q \times R, \alpha \rhd
\beta)$ where $(\alpha \rhd \beta)((a,b) , (q , r)) = \alpha(a , q)
\mathop{\mathsf{land}} \beta(i , r)$, and $\mathop{\mathsf{land}}$ is
lazy conjunction defined for $\mathsf{3}$\footnote{See the formal
  development for the full definition:
  \url{https://github.com/heades/dialectica-spaces/blob/GraMSec16/concrete-lineales.agda\#L648}}.
This is a non-symmetric conjunctive operator, and thus, sequential
composition is non-symmetric.  This implies that from a process
perspective $\cat{A} \rhd \cat{B}$ will first execute the actions of
$\cat{A}$ and then execute actions of $\cat{B}$ in that order.
Sequential composition is associative.
\end{changemargin}

\begin{changemargin}{2pt}{2pt}\noindent
\textbf{Interacting Parallel Composition.} Suppose $\cat{A} = (A , Q,
\alpha)$ and $\cat{B} = (B , R , \beta)$ are two dialectica spaces.
Then we can construct the dialectica space $\cat{A} \otimes \cat{B} =
(A \times B, (B \rightarrow Q) \times (A \rightarrow R), \alpha
\otimes \beta)$ where $B \to Q$ and $A \to R$ denote function spaces,
and $(\alpha \otimes \beta)((a, b) , (f, g)) = \alpha(a , f(b)) \land
\beta(b,g(a))$.  From a process perspective the actions of $\cat{A}
\otimes \cat{B}$ are actions from $\cat{A}$ and actions of $\cat{B}$,
but the states are pairs of maps $f : B \to Q$ and $g : A \to R$ from
actions to states.  This is the point of interaction between the
processes.  This operator is symmetric and associative.
\end{changemargin}

\begin{changemargin}{2pt}{2pt}\noindent
\textbf{Copying.} Suppose $\cat{A} = (A , Q, \alpha)$ is a dialectica
space. Then $\textcopyright\cat{A} = (A, A \to Q^*, \alpha^*)$ where
$Q^*$ denotes the free monoid with carrier $Q$ and $\alpha^*$ is the
free monoid extension of $\alpha$.  Copying defines a comonad
$\textcopyright : \dial \to \dial$ on the category of dialectica
spaces, and thus, we have dialectica morphisms $\varepsilon :
\textcopyright A \to A$ and $\delta : \textcopyright A \to
\textcopyright\textcopyright A$ satisfying the usual diagrams.
Furthermore, it has enough structure to show the isomorphism
$(\textcopyright\cat{A} \otimes \textcopyright\cat{A}) \cong
\textcopyright\cat{A}$.  This implies that under $\textcopyright$ we
escape to propositional logic.
\end{changemargin}
} At this point it is straightforward to define an interpretation
$\interp{[[t]]}$ of attack trees into $\dial$.  Soundness with respect
to this model would correspond to if $[[t1]] \rightsquigarrow [[t2]]$,
then $\interp{[[t1]]} \cong \interp{[[t2]]}$ where $\cong$ is
isomorphism of objects.  The definition of choice is the definition
given for Chu spaces \cite{Gupta:1994}, but Brown et al. use the
coproduct defined for dialectica spaces to model choice in Petri nets.
However, taking the coproduct for choice here does not lead to the
isomorphisms $(\cat{A} \sqcup \cat{B}) \rhd \cat{C} \cong (\cat{A}
\rhd \cat{C}) \sqcup (\cat{B} \rhd \cat{C})$ and $(\cat{A} \sqcup
\cat{B}) \odot \cat{C} \cong (\cat{A} \odot \cat{C}) \sqcup (\cat{B}
\odot \cat{C})$, thus, we will not be able to soundly model attack
trees.  I have found that if choice is modeled using the definition
from Chu spaces \cite{Gupta:1994} then we obtain these isomorphisms
which is a novel result\footnote{For the proofs see the formal
  development:
  \url{https://github.com/heades/dialectica-spaces/blob/GraMSec16/concurrency.agda\#L70}
  and
  \url{https://github.com/heades/dialectica-spaces/blob/GraMSec16/concurrency.agda\#L150}}.

This semantics can be seen as a generalization of some existing
models.  Multisets, pomsets, and Petri nets can all be modeled by
dialectica spaces \cite{Brown:1991,Gupta:1994}.  However, there is a
direct connection between dialectica spaces and linear logic which
may lead to a logical theory of attack trees.
% section concrete_semantics_of_attack_trees_in_dialectica_spaces (end)

\section{Lina: A Domain Specific PL for Threat Analysis}
\label{sec:lina:_a_domain_specific_pl_for_threat_analysis}

The second major part of this project is the development of a
staticly-typed polymorphic domain-specific linear functional
programming language for specifying and reasoning about attack trees
called Lina for Linear Threat Analysis.  Lina will consist of a core
language and a surface language.  The core language will include a
decidable type checker using term annotations on types.  Programming
with annotations can be very cumbersome, and so the surface language
will use local type inference \cite{Pierce:2000} to alleviate some of
the burden from annotations.  However, the surface language will
provide further conveniences in the form of automation, to be used
with labeled attack trees, and graphical representations of attack
trees based on the various graphical languages used in category theory
\cite{Selinger:2009}.  Thus, the security specialist will not be
required to program directly in Lina, but instead will use a graphical
interface to construct attack trees and prove properties about them.

Types in Lina will correspond to attack trees while programs
correspond to semantically valid transformations of attack trees,
thus, a question we must answer then is \textbf{how do we sufficiently
  represent the model of attack trees in $\dial$ as a linear logic?}
The problem is the fact that Lina will require both commutative
monoidal operators and non-communicative monoidal
operators. Supporting both types of operators within the same logic
has been a long standing question.  A starting point might be with
Reedy's LLMS which has already been shown to have a categorical model
in $\dial$ by de Paiva \cite{dePaiva:2014a}.  A different path the
project plans to develop is to start with a non-communicative linear
logic and then split up the of-course exponential into three new
exponential operators: one that adds symmetry, one that adds
weakening, and one that adds contraction.  This would allow for the
specification of multiple types of monoidal operators using the
various exponentials.  Once a proper linear logic is laid out the next
step will be to exploit the Curry-Howard-Lambek correspondence to
obtain a linear functional programming language making up the core of
Lina.
% section lina:_a_domain_specific_pl_for_threat_analysis (end)

\section{Conclusion}
\label{sec:conclusion}

The project described here is to first develop the semantics of attack
trees (Section~\ref{sec:attack_trees}) in dialectica spaces
(Section~\ref{sec:concrete_semantics_of_attack_trees_in_dialectica_spaces}),
a model of full intuitionistic linear logic, and then exploiting the
Curry-Howard-Lambek correspondence to develop a new functional
programming language called Lina
(Section~\ref{sec:lina:_a_domain_specific_pl_for_threat_analysis}) to
be used to develop a new tool to conduct threat analysis using attack
trees.  This tool will include the ability to design and formally
reason about attack trees using interactive theorem proving.
% section conclusion_and_future_work (end)


\bibliographystyle{plain} \bibliography{ref}

\appendix

\section{Symmetric Monoidal Categories}
\label{sec:symmetric_monoidal_categories}
\input{appendix-SMC}
% section symmetric_monoidal_categories (end)

\section{Source Sink Graphs are Symmetric Monoidal}
\label{sec:source_sink_graphs_are_symmetric_monoidal}
\input{appendix-SSG-monoidal}
% section source_sink_graphs_are_symmetric_monoidal (end)


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

