\documentclass{llncs}

\usepackage{amssymb,amsmath}
\usepackage{cmll}
\usepackage{stmaryrd}
\usepackage{todonotes}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[barr]{xy}

%% This renames Barr's \to to \mto.  This allows us to use \to for imp
%% and \mto for a inline morphism.
\let\mto\to
\let\to\relax
\newcommand{\to}{\rightarrow}

% Commands that are useful for writing about type theory and programming language design.
%% \newcommand{\case}[4]{\text{case}\ #1\ \text{of}\ #2\text{.}#3\text{,}#2\text{.}#4}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\normto}[0]{\rightsquigarrow^{!}}
\newcommand{\join}[0]{\downarrow}
\newcommand{\redto}[0]{\rightsquigarrow}
\newcommand{\nat}[0]{\mathbb{N}}
\newcommand{\fun}[2]{\lambda #1.#2}
\newcommand{\CRI}[0]{\text{CR-Norm}}
\newcommand{\CRII}[0]{\text{CR-Pres}}
\newcommand{\CRIII}[0]{\text{CR-Prog}}
\newcommand{\subexp}[0]{\sqsubseteq}
%% Must include \usepackage{mathrsfs} for this to work.
\newcommand{\powerset}[0]{\mathscr{P}}

\date{}

% Cat commands.
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\catop}[1]{\cat{#1}^{\mathsf{op}}}
\newcommand{\Hom}[3]{\mathsf{Hom}_{\cat{#1}}(#2,#3)}
\newcommand{\limp}[0]{\multimap}
\newcommand{\dial}[0]{\mathsf{Dial_2}(\mathsf{Sets})}
\newcommand{\dialSets}[1]{\mathsf{Dial_{#1}}(\mathsf{Sets})}
\newcommand{\dcSets}[1]{\mathsf{DC_{#1}}(\mathsf{Sets})}
\newcommand{\sets}[0]{\mathsf{Sets}}
\newcommand{\obj}[1]{\mathsf{Obj}(#1)}
\newcommand{\mor}[1]{\mathsf{Mor(#1)}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\lett}[0]{\mathsf{let}\,}
\newcommand{\inn}[0]{\,\mathsf{in}\,}
\newcommand{\cur}[1]{\mathsf{cur}(#1)}
\newcommand{\curi}[1]{\mathsf{cur}^{-1}(#1)}

\newenvironment{changemargin}[2]{%
  \begin{list}{}{%
    \setlength{\topsep}{0pt}%
    \setlength{\leftmargin}{#1}%
    \setlength{\rightmargin}{#2}%
    \setlength{\listparindent}{\parindent}%
    \setlength{\itemindent}{\parindent}%
    \setlength{\parsep}{\parskip}%
  }%
  \item[]}{\end{list}}

%% Ott
\input{atrees-ott}

\begin{document}

\title{Proposing a New Foundation of Attack Trees in Monoidal Categories}

\author{Harley Eades III}
\institute{Computer and Information Sciences, Augusta University, Augusta, GA, \email{heades@augusta.edu}}

\maketitle 

\begin{abstract}
  TODO
\end{abstract}

\section{Introduction}
\label{sec:introduction}

What do propositional logic, multisets, directed acyclic graphs,
source sink graphs (or parallel-series pomsets), Petri nets, and
Markov processes all have in common?  They are all mathematical models
of attack trees \cite{??}, but even more than that, they can all be
modeled in some form of a symmetric monoidal category\footnote{We
  provide a proof that the category of source sink graphs is monoidal
  in Appendix~\ref{sec:source_sink_graphs_are_symmetric_monoidal}.}
\cite{?} -- for the definition of a symmetric monoidal category see
Appendix~\ref{sec:symmetric_monoidal_categories}.  Taking things a
little bit further, monoidal categories have a tight correspondence
with linear logic through the beautiful Curry-Howard-Lambek
correspondence \cite{?}.  This correspondence states that objects of a
monoidal category correspond to the formulas of linear logic and the
morphisms correspond to proofs of valid sequents of the logic.  I
propose that attack trees -- in many different flavors -- be modeled
as objects in monoidal categories, and hence, as formulas of linear
logic.

The Curry-Howard-Lambek correspondence is a three way relationship:
\begin{center}
  \setlength{\tabcolsep}{7pt}
  \begin{tabular}{ccccc}
    Categories & $\iff$ & Logic    & $\iff$   & Functional Programming\\
    Objects    & $\iff$ & Formulas & $\iff$   & Types    \\
    Morphisms  & $\iff$ & Proofs   & $\iff$   & Programs 
  \end{tabular}
\end{center}
By modeling attack trees in monoidal categories we obtain a sound
mathematical model, a logic for reasoning about attack trees, and the
means of constructing a functional programming language for defining
attack trees (as types), and constructing semantically valid
transformations (as programs) of attack trees.  Keep in mind that as
stated ``semantically valid transformations as programs'' is very
broad, because this may turn out to be something other than morphisms
between attack trees, e.g. it may turn out to be bi-simulation between
processes instead.

Linear logic was first proposed by Girard \cite{?} and was quickly
realized to be a theory of resources.  In linear logic, every
hypothesis must be used exactly once.  Thus, formulas like $A \otimes
A$ and $A$ are not logically equivalent -- here $\otimes$ is linear
conjunction.  This resource perspective of linear logic has been very
fruitful in computer science.  It has lead to linear logic as being a
logical foundation of concurrency \cite{?} where formulas may be
considered as processes.  This perspective fits modeling attack trees
perfectly, because they essentially correspond to concurrent
processes.  Connecting attack trees to processes has been done before
where they have been modeled by event-based models of concurrency like
Petri nets and partially-ordered multisets (pomsets) \cite{?}.  In
fact, pomsets is a model in which events (the resources) can be
executed exactly once \cite{?}, and thus, has a relationship with
linear logic \cite{?}.  However, connecting linear logic as a theory
of attack trees is novel.

Girard's genius behind linear logic was that he isolated the
structural rules -- weakening and contraction -- by treating them as
an effect and putting them inside a comonad called the of-course
exponential denoted $!A$.  In fact, $!A \otimes !A$ is logically
equivalent to $!A$, and thus, by staying in the comonad we become
propositional.  This implies that a modal of attack trees in linear
logic also provides a model of attack trees in propositional logic,
and a combination of the two.  It is possible to have the best of both
worlds.

In this short paper I introduce a newly funded research
project\footnote{This material is based upon work supported by the
  National Science Foundation CRII CISE Research Initiation grant,
  ``CRII:SHF: A New Foundation for Attack Trees Based on Monoidal
  Categories``, under Grant No. 1565557.}  investigating founding
attack trees in monoidal categories, and through the
Curry-Howard-Lambek correspondence deriving a new domain-specific
functional programming language called Lina for Linear Threat
Analysis.  I begin by defining an extension of the attack trees given
in \cite{Jhawar:2015} in Section~\ref{sec:attack_trees}.  Then I
introduce a new semantics of attack trees in dialectica spaces, which
is also a model of full intuitionistic linear logic, in
Section~\ref{sec:concrete_semantics_of_attack_trees_in_dialectica_spaces}.
The final section,
Section~\ref{sec:lina:_a_domain_specific_pl_for_threat_analysis},
discusses Lina and some of the current problems the project seeks to
answer.
% section introduction (end)

\section{Attack Trees}
\label{sec:attack_trees}
In this paper I consider an extension of attack trees with sequential
composition which are due to Jhawar et al. \cite{Jhawar:2015}, but one
of our ultimate goals is to extend attack trees with even more
operators driven by are choice of semantics.  The syntax for attack
trees is defined in the following definition.
\begin{definition}
  \label{def:atrees}
  The following defines the syntax of \textbf{Attack Trees} given a set
  of base attacks $b \in \mathsf{B}$:
  \[
  \begin{array}{lll}
    t ::= [[b]] \mid [[t1 + t2]] \mid [[t1 (+) t2]] \mid [[t1;t2]] \mid [[t1 (x) t2]] \mid [[! t ]]\\
  \end{array}
  \]
  We denote parallel composition by $[[t1 + t2]]$, choice between
  attacks $[[t1]]$ and $[[t2]]$ by $[[t1 (+) t2]]$, sequential
  composition of attacks by $[[t1;t2]]$, a new operator called
  orthocurrence by $[[t1 (x) t2]]$, and finally a new operator called
  copy by $[[! t]]$.

  \ \\
  \noindent
  The following rules define the attack tree reduction relation:
  \begin{center}
    \vspace{-25px}
    \footnotesize
    \begin{mathpar}
      \inferrule* [right={\footnotesize assoc}] {
        \,
      }{[[(t1 op t2) op t3]] \redto [[t1 op (t2 op t3)]]}
      \and
      \inferrule* [right={\footnotesize sym}] {
        \,
      }{[[t1 opS t2]] \redto [[t2 opS t1]]}
      \and
      \inferrule* [right={\footnotesize choice}] {
        \,
      }{[[t (+) t]] \redto [[t]]}
      \and
      \inferrule* [right={\footnotesize copy}] {
        \,
      }{[[h(!t) (x) !t]] \redto [[!t]]}            
      \and
      \inferrule* [right={\footnotesize $\textsc{dist}_1$}] {
        \,
      }{[[(t1 (+)  t2) + t]] \redto [[(t1 + t) (+) (t2 + t)]]}
      \and
      \inferrule* [right={\footnotesize $\textsc{dist}_2$}] {
        \,
      }{[[(t1 (+)  t2) ; t]] \redto [[(t1 ; t) (+) (t2 ; t)]]}
    \end{mathpar}
  \end{center}
  where $\mathsf{op} \in \{+, \otimes, ;, \sqcup\}$ and $\mathsf{op_S}
  \in \{+, \otimes, \sqcup\}$.  The previous rules can be applied on
  any well-formed subattack tree. The equivalence relation, denoted
  $\equiv$, on attack trees is defined as the reflexive, symmetric,
  and transitive closure of the reduction relation $\redto$.
\end{definition}
The syntax given in the previous definition differs from the syntax
used by Jhawar et al. \cite{Jhawar:2015}.  First, I use infix binary
operations, while they use prefix $n$-ary operations. However, it does
not sacrifice any expressivity, because as we will see in the next
section each operation is associative, and parallel composition,
choice, and orthocurrence are symmetric.  Thus, we can embed Jhawar et
al.'s definition of attack trees into the ones defined here.  The hard
part of this embedding is realizing that the $n$-ary version of
sequential composition can be modeled by the binary version, but if we
have $\mathsf{SAND}(t_1,t_2,\ldots,t_n)$, then it is understood that
$t_1$ is executed, then $t_2$, and so on until $t_n$ is executed, but
this is exactly the same as $t_1;t_2;\cdots;t_n$.  

The second major difference is that I denote parallel composition with
an operator that implies we can think of it as a disjunction, but
Jhawar et al. and others in the literature seem to use an operator
that implies that we can think of it as a conjunction.  The semantics,
however, tells us that it is really a disjunction.  The parallel
operation defined on source sink graphs defined by Jhawar et
al. \cite{Jhawar:2015} can be proven to be a coproduct -- see
Appendix~\ref{sec:source_sink_graphs_are_symmetric_monoidal} -- and
coproducts categorically model disjunctions.  Furthermore, parallel
composition is modeled by multiset union in the multiset semantics,
but we can model this as a coproduct.  Lastly, the semantics I give in
the next section models parallel composition as a coproduct.  Thus, I
claim that an operator that reflects this is for the better.

The third difference is that I denote the choice between executing
attack $[[t1]]$ or attack $[[t2]]$, but not both, by $[[t1 (+) t2]]$
instead of using a symbol that implies that it is a disjunction.  This
fits very nicely with the semantics of Jhawar et al., where they
collect the attacks that can be executed into a set.  The semantics I
given in the next section models choice directly.

The forth, and final, difference is that we extend the syntax with two
new operators called orthocurrence and copy.  The attack $[[t1 (x)
    t2]]$ states that $[[t1]]$ interacts with the attack $[[t2]]$ in
the sense that processes interact.  Modeling interacting attacks
allows for the more refined modeling of security critical systems.
For example, one could take over a workstation on a network and funnel
malicious traffic through it onto the internal network.  Orthocurrence
stems from process algebra, and for more examples, and a brief history
of orthocurrence see \cite{Pratt:2001}.  In fact, this operator points
out a theme to the project being described in this paper.  We view
attack trees as describing concurrent interacting processes.  Thus, we
can learn a lot from process algebra.

Orthocurrence actually hints at an interesting extension of attack
trees with interacting parties.  For example, it can be used to bring
social engineering into the analysis where someone communicates
malicious information or commands to a unsuspecting party.  That is,
attack trees could be extended with nodes representing people or
devices communicating information from/through one process to
another. I conjecture that it should be possible to extend Jhawar et
al.'s model of attack trees to include orthocurrence due to the
relationship their model has with partially-ordered multisets which is
where orthocurrence actually originated \cite{?}.

The attack $[[! t]]$ indicates that attack $[[t]]$ can be copied and
contracted.  For example, $[[! (t (x) t)]]$ is equivalent to $[[!
    t]]$.  Thus, the attack trees given here can treat attack trees as
processes/resources that cannot be freely copied and deleted, but also
as propositions that can be, but even further, these two perspectives
can be mixed.  Semantically, $[[! t]]$ is equivalent to the of-course
exponential from linear logic mentioned in the introduction.

The reduction rules are a slightly extended version of equivalences
given in Jhaware et al. \cite{Jhawar:2015} -- Theorem 1.  The main
difference is the $\textsc{Copy}$ rule which allows copies made by the
copy operator to be contracted.
% section attack_trees (end)

\section{Semantics of Attack Trees in Dialectica Spaces}
\label{sec:concrete_semantics_of_attack_trees_in_dialectica_spaces}

I now introduce a new semantics of attack trees that connects their
study with two new perspectives that could highly impact future
research in attack trees: intuitionistic linear logic and process
calculi.  Note that every construction and proof given in this section
with the exception of sequential composition has been formalized in
the proof assistant Agda\footnote{The complete formalization can be
  found at \url{https://github.com/heades/dialectica-spaces} which is
  part of a general library for working with dialectica spaces in Agda
  developed with Valeria de Paiva.}.  The semantics is based on the
notion of a dialectica space:

\begin{definition}
  \label{def:dialectica-space}
  A \textbf{dialectica space} is a triple $(A, Q, \delta)$ where $A$
  and $Q$ are sets and $\delta : A \times Q \to \mathsf{2}$ is a
  relation.
\end{definition}
Dialectica spaces can be seen as the intuitionistic cousin
\cite{dePaiva:2006b} of Chu spaces \cite{Pratt:1999}.  The latter have
be used extensively to study process algebra and as a model of
classical linear logic, while dialectica spaces and their morphisms
form a model of full intuitionistic linear logic \cite{?}. I will use
the intuitions often used when explaining Chu spaces to explain
dialectica spaces, but it should be known that these intuitions are
due to Pratt and Gupta \cite{?}.  However, verifying that the Chu
space construction of choice and sequential composition works in
dialectica spaces is novel and so is the application of this semantics
to attack trees.

Intuitively, we can think of a dialectica space, $(A , Q, \delta)$, as
a process where $A$ is the set of actions the process will execute,
$Q$ is the set of states the process can enter, and for $a \in A$ and
$q \in Q$, $\delta(a , q)$ indicates whether action $a$ can be
executed in state $q$.  

Dialectica spaces form the objects of a category called $\dial$.  This
category has an abundance of structure.  The definition $\dial$
requires the notion of a morphism between dialectica spaces.
\begin{definition}
  \label{def:dial-space-morphism}
  A \textbf{dialectica-space morphism} between dialectica spaces
  \\ $(A , Q, \alpha)$ and $(B , R , \beta)$ is a tuple $(f, F)$ where
  $f : A \to B$ and $F : R \to Q$ such that the following weak
  adjointness condition holds:
    for any $a \in A$ and $r \in R$, if $\alpha(a,F(r))$, then
    $\beta(f(a), r)$. 
\end{definition}
Proving that we have a category takes a little bit of work, but all
the details can be found in the formal development.  The category
$\dial$ forms one of the earliest models of linear logic, and is the
first model of intuitionistic linear logic that contains every linear
operator. It is originally due to de Paiva \cite{?}. For more
information on how it relates to linear logic see \cite{Eades:2016}.

The interpretation of attack trees into dialectica spaces, each
definition is equivalent to the construction on Chu spaces \cite{?},
requires the construction of each operation on dialectica spaces:
{\vspace{-10pt}\footnotesize\ \\
\begin{changemargin}{3pt}{3pt}\noindent
\textbf{Parallel Composition.} Suppose $\cat{A} = (A , Q, \alpha)$ and
$\cat{B} = (B , R , \beta)$ are two dialectica spaces.  Then we can
construct the dialectica space $\cat{A} + \cat{B} = (A + B, Q \times
R, \alpha + \beta)$ where $A + B$ is the disjoint union of $A$ and
$B$, and $\alpha + \beta : (A + B) \times (Q \times R) \to \mathsf{2}$
is defined by $(\alpha + \beta)(i , x) = \alpha(i , x)$ if $i \in A$,
but $(\alpha + \beta)(i , x) = \beta(i , x)$ if $i \in B$.  Thus, from
a process perspective we can see that $\cat{A} + \cat{B}$ executes
either an action of $\cat{A}$ or an action of $\cat{B}$, but also
potentially both, however this requires $\cat{A} + \cat{B}$ be a
coproduct.  It turns out that we can show that parallel composition is
a coproduct, the details can be found in the formal development.
Thus, it is associative and symmetric.
\end{changemargin}

\begin{changemargin}{3pt}{3pt}\noindent
\textbf{Choice.} Suppose $\cat{A} = (A , Q, \alpha)$ and $\cat{B} = (B
, R , \beta)$ are two dialectica spaces.  Then we can construct the
dialectica space $\cat{A} \sqcup \cat{B} = (A + B, Q + R, \alpha
\sqcup \beta)$ where $\alpha \sqcup \beta : (A + B) \times (Q + R) \to
\mathsf{2}$ is defined by $(\alpha \sqcup \beta)(i , j) = \alpha(i ,
j)$ if $i \in A$ and $j \in Q$, $(\alpha + \beta)(i , j) = \beta(i ,
j)$ if $i \in B$ and $j \in R$, otherwise $(\alpha + \beta)(i , j) =
0$.  Thus, from a process perspective we can see that $\cat{A} \sqcup
\cat{B}$ executes either an action of $\cat{A}$ or an action of
$\cat{B}$, but not both.  Since the actions and states of $\cat{A}
\sqcup \cat{B}$ are disjoint unions it is pretty easy to show that
choice forms a symmetric monoidal operator, and hence, is symmetric
and associative, but it is not a coproduct, because it is not possible
to define the corresponding injections.
\end{changemargin}

\begin{changemargin}{3pt}{3pt}\noindent
\textbf{Sequential Composition.} Modeling sequential conjunction
requires we extend the notion of dialectic space with the ability to
determine which states of the space are initial and which are final,
but this is straightforward.  Suppose $\cat{A} = (A , Q, \alpha)$ and
$\cat{B} = (B , R , \beta)$ are two dialectica spaces.  Then we can
construct the dialectica space $\cat{A};\cat{B} = (A + B, Z,
\alpha;\beta)$ where $Z = \{(q_1 , q_2) \in Q \times R \mid q_1 \text{
  is final in } \cat{A} \text{ or } q_2 \text{ is initial in }
\cat{B}\}$, and $\alpha;\beta : (A + B) \times Z \to \mathsf{2}$ is
defined by $(\alpha \sqcup \beta)(i , (q , r)) = \alpha(i , q)$ if $i
\in A$, $(\alpha;\beta)(i , (q , r)) = \beta(i , r)$ if $i \in B$.
Thus, from a process perspective we can see that $\cat{A};\cat{B}$
will first execute the actions of $\cat{A}$ and then once in a final
state it will begin executing actions of $\cat{B}$.  It can be shown
that sequential composition is a non-symmetric associative operation.
\end{changemargin}

\begin{changemargin}{3pt}{3pt}\noindent
\textbf{Orthocurrence.} Suppose $\cat{A} = (A , Q, \alpha)$ and
$\cat{B} = (B , R , \beta)$ are two dialectica spaces.  Then we can
construct the dialectica space $\cat{A} \otimes \cat{B} = (A \times B,
(B \rightarrow Q) \times (A \rightarrow R), \alpha \otimes \beta)$
where $B \to Q$ and $A \to R$ denote function spaces, and $\alpha
\otimes \beta : (A \times B) \times ((B \rightarrow Q) \times (A
\rightarrow R)) \to \mathsf{2}$ is defined by $(\alpha \otimes
\beta)((a, b) , (f, g)) = \alpha(a , f(b)) \land \beta(b,g(a))$.  From
a process perspective the actions of $\cat{A} \otimes \cat{B}$ are
actions from $\cat{A}$ and actions of $\cat{B}$, but the states are
are maps $(f , g)$ where $f : B \to Q$ and $g : A \to R$ from actions
to states.  This is the point of interaction between the processes
$\cat{A}$ and $\cat{B}$.  It is possible to show that orthocurrence is
a symmetric monoidal bi-functor which is symmetric, associative, and
has an identity, but for the details see the formal development.
\end{changemargin}

\begin{changemargin}{3pt}{3pt}\noindent
\textbf{Copying.} Suppose $\cat{A} = (A , Q, \alpha)$ is a dialectica
space. Then $\textcopyright\cat{A} = (A, A \to Q^*, \alpha^*)$ where
$Q^*$ denotes the free monoid with carrier $Q$.  Copying defines a
functor such that if we have a morphism $f : \cat{B} \to \cat{C}$,
then we obtain a morphism $\textcopyright f : \textcopyright\cat{B}
\to \textcopyright\cat{C}$.  Furthermore, $\textcopyright : \dial \to
\dial$ defines a comonad on the category of dialectica spaces, and
thus, we have dialectica morphisms $\varepsilon : \textcopyright A \to
A$ and $\delta : \textcopyright A \to \textcopyright\textcopyright A$
satisfying the usual diagrams.
Therefore, we have an isomorphism
$(\textcopyright\cat{A} \otimes \textcopyright\cat{A}) \cong \textcopyright\cat{A}$.  This implies that under
$\textcopyright$ we escape to propositional logic. 
\end{changemargin}
} At this point it is straightforward to define an interpretation
$\interp{[[t]]}$ of attack trees into $\dial$.  Soundness with respect
to this model would correspond to if $[[t1]] \rightsquigarrow [[t2]]$,
then $\interp{[[t1]]} \cong \interp{[[t2]]}$ where the latter takes
place in $\dial$ for some suitable equivalence $\cong$ between
objects.  Naturally, one might choose isomorphism, but this does not
hold, because the reduction rules $\textsc{copy}$, $\textsc{dist}_1$,
and $\textsc{dist}_2$ do not hold up to isomorphism of objects, but we
conjecture if we take $\cong$ to be bi-simulation as defined for Chu
spaces -- see p. 63 of Gupta \cite{?} -- then we obtain the proper
equivalences.  These equivalences will need to be verified for
dialectica spaces, but I do not see any barriers preventing this.

This semantics can be seen as a generalization of some existing
models.  Multisets, pomsets, and Petri nets can all be modeled by
dialectica spaces \cite{?}.  However, there is a direct connection
between dialectica spaces and linear logic which leads to a logical
theory of attack trees.
% section concrete_semantics_of_attack_trees_in_dialectica_spaces (end)

\section{Lina: A Domain Specific PL for Threat Analysis}
\label{sec:lina:_a_domain_specific_pl_for_threat_analysis}

The second major part of this project is the development of a
staticly-typed polymorphic domain-specific linear functional
programming language for specifying and reasoning about attack trees
called Lina for Linear Threat Analysis.  Lina will consist of a core
language and a surface language.  The core language will include a
decidable type checker using term annotations on types; note that type
checking becomes undecidable in the presence of parametric
polymorphism \cite{Wells:1999}.  Programming with annotations can be
very cumbersome, and so the surface language will use local type
inference \cite{Pierce:2000} to alleviate some of the burden from
annotations.  However, the surface language will provide further
conveniences in the form of automation, to be used with labeled attack
trees, and graphical representations of attack trees based on the
various graphical languages used in category theory
\cite{Selinger:2009}.  Thus, the security specialist will not be
required to program directly in Lina, but instead will only be
required to use a graphical interface to construct attack trees and
prove properties about them.

There are two main questions that still must be answered in order for
all this to work.  First, linear logic generally does not include
operators like choice and sequential composition, and hence, in order
to build Lina we must figure out how to add these operators to linear
logic.  It should be enough to add a new non-commutative monoidal
operator for sequential conjecture to linear logic along with a new
symmetric monoidal operator for choice.  It seems the former has been
done in classical linear logic \cite{?}, but it remains to be seen if
it can be done in intuitionistic linear logic.

Second, programs are seen as proofs/dialectica space morphisms, but we
know that the morphisms of $\dial$ do not capture all of the structure
of the attack trees, and hence, we must move to bi-simulation of
dialectica spaces to obtain a sound model of attack trees.  So one
important question we must answer is do all of isomorphisms between
dialectica spaces in $\dial$ lift to equivalences using bi-simulation?
If yes, then we may consider programs as bi-simulations, and hence,
obtain the proper structure to soundly model attack trees.
% section lina:_a_domain_specific_pl_for_threat_analysis (end)

\section{Conclusion}
\label{sec:conclusion}
The project described here is to first develop the semantics of attack
trees (Section~\ref{sec:attack_trees}) in dialectica spaces
(Section~\ref{sec:concrete_semantics_of_attack_trees_in_dialectica_spaces}),
a model of full intuitionistic linear logic, and then exploiting --
and extending -- the Curry-Howard-Lambek correspondence to develop a
new functional programming language called Lina
(Section~\ref{sec:lina:_a_domain_specific_pl_for_threat_analysis}) to
be used to develop a new tool to conduct threat analysis using attack
trees.  This tool will include the ability to design and formally
reason about attack trees using interactive theorem proving.
% section conclusion_and_future_work (end)


\bibliographystyle{plain} \bibliography{ref}

\appendix

\section{Symmetric Monoidal Categories}
\label{sec:symmetric_monoidal_categories}
\input{appendix-SMC}
% section symmetric_monoidal_categories (end)

\section{Source Sink Graphs are Symmetric Monoidal}
\label{sec:source_sink_graphs_are_symmetric_monoidal}

% section source_sink_graphs_are_symmetric_monoidal (end)


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

