In this section we take what we have learned by constructing the
dialectica model and define a intuitionistic linear logic, called the
attack tree linear logic (ATLL), that can be used to prove
equivalences between attack trees as linear implications.  ATLL is
based on the logic of bunched implications (BI) \cite{Ohearn:2003}, in
that, contexts will be trees.  This is necessary to be able to include
parallel and sequential conjunction, and choice within the same logic,
because they all have different structural rules associated with them.

The syntax for formulas and contexts are defined by the following
grammar.
\begin{center}
  \begin{math}
    \begin{array}{lll}
      [[A]],[[B]],[[C]],[[d]],[[T]] := [[N]] \mid [[A + B]] \mid [[A
          (.) B]] \mid [[A > B]] \mid [[A -o B]]\\
      [[G]],[[D]] := [[*]] \mid [[A]] \mid [[G , D]] \mid [[G ; D]] \mid
      [[G . D]]\\
    \end{array}
  \end{math}
\end{center}
ATLL formulas are not surprising, but we denote base attacks by atomic
formulas represented here by $[[N]]$.  The syntax for contexts are
similar to the contexts in BI.  Contexts are trees with three types of
nodes denoted by $[[G,D]]$ for parallel conjunction, $[[G;D]]$ for
sequential conjunction, and $[[G . D]]$ for choice.  They all have
units, but we overload the symbol $[[*]]$ to represent them all.

The ATLL inference rules are given in Figure~\ref{fig:atll-rules}.
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \ATLLdruleLXXvar{} \and
      \ATLLdruleLXXnode{} \and
      \ATLLdruleLXXCtx{} \and
      \ATLLdruleLXXparaI{} \and
      \ATLLdruleLXXchoiceI{} \and
      \ATLLdruleLXXseqI{} \and
      \ATLLdruleLXXparaE{} \and
      \ATLLdruleLXXchoiceE{} \and
      \ATLLdruleLXXseqE{} \and
      \ATLLdruleLXXlimpI{} \and
      \ATLLdruleLXXlimpE{}
    \end{mathpar}
  \end{mdframed}
  \caption{ATLL Inference Rules}
  \label{fig:atll-rules}
\end{figure}
The inference rules are fairly straightforward.  We denote by
$[[D(G)]]$ the context $[[D]]$ with a subtree -- subcontext --
$[[G]]$.  This syntax is used to modify the context across inference
rules.

Perhaps the most interesting rule is the $\text{CM}$ rule which stands
for context morphism.  This rule is a conversion rule for manipulation
of the context.  It depends on a judgment $[[G1 |- G2]]$ which can be
read as the context $[[G1]]$ can be transformed into the context
$[[G2]]$.  This judgment is defined by the rules in
Figure~\ref{fig:atll-cm-rules}.
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \ATLLdruleCXXid{} \and
      \ATLLdruleCXXc{} \and
      \ATLLdruleCXXaOne{} \and
      \ATLLdruleCXXuOne{} \and
      \ATLLdruleCXXuTwo{} \and
      \ATLLdruleCXXeOne{} \and
      \ATLLdruleCXXeTwo{} \and
      \ATLLdruleCXXdOne{} \and
      \ATLLdruleCXXdTwo{} \and
      \ATLLdruleCXXdThree{} \and
      \ATLLdruleCXXdFour{} \and
    \end{mathpar}
  \end{mdframed}
  \caption{Context Morphisms}
  \label{fig:atll-cm-rules}
\end{figure}
Context morphisms are designed to induce structural rules for some of
the logical connectives and not for others.  For example, parallel
conjunction and choice should be commutative, but sequential
conjunction should not be.  The rules for associativity and the unit
rules mention the operator, $\circ$, this operator ranges over '$,$',
'$;$', and '$\bullet$'.

One interesting, and novel aspect of this logic in contrast to BI is
we can use the context morphisms to induce distributive laws between
the various tensor products.  The rules $\text{dist}_1$ and
$\text{dist}_2$ induce the property that sequential conjunction
distributes over choice, and $\text{dist}_3$ and $\text{dist}_4$
induce the property that parallel conjunction distributes over choice.

The interpretation of attack trees as ATLL formulas is obvious at this
point where base attacks are atomic formulas and we denote this
interpretation as $\interp{[[T]]}$ for some attack tree $[[T]]$.  The
most interesting part about this interpretation is that we can now use
linear implication to prove properties about attack trees.  First, we
can derive all of the required equivalences in ATLL.
\begin{lemma}[Attack Tree Logical Equivalences]
  \label{lemma:attack_tree_logical_equivalences}
  The following hold for any ATLL formulas $[[A]]$, $[[B]]$, and $[[C]]$.
  \begin{itemize}
  \item $[[* |- (A + B) o-o (B + A)]]$
  \item $[[* |- (A (.) B) o-o (B (.) A)]]$
  \item $[[* |- ((A + B) + C) o-o (A + (B + C))]]$
  \item $[[* |- ((A (.) B) (.) C) o-o (A (.) (B (.) C))]]$
  \item $[[* |- ((A > B) > C) o-o (A > (B > C))]]$
  \item $[[* |- (A (.) (B + C)) o-o ((A (.) B) + (A (.) C))]]$
  \item $[[* |- (A > (B + C)) o-o ((A > B) + (A > C))]]$
  \end{itemize}
\end{lemma}
Using the previous lemma we can now completely reason about
equivalences of attack trees in ATLL.  Another important aspect of
ATLL is that we can use either the left-to-right directions or the
right-to-left directions of the previous bi-implications to simplify
attack trees into normal forms.  In addition, the logical
interpretation leads to new and interesting questions, for example,
adding additional structural rules, like weakening, could also open
the door for proving when one attack tree is a subattack tree of
another.  This concept is yet to appear in the literature, but has
practical applications.

