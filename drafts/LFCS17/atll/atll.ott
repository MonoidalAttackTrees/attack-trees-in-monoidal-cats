embed
  {{tex-preamble \usepackage{cmll}
                 \usepackage{relsize} }}

metavar costvar, c ::=
metavar termvar, x, y , z, f ::=
metavar baseAttackVars, N ::=
metavar baseAttackTVars, n ::= 
indexvar index, i , j, k ::=

grammar
  A, B, C, E, F, d {{tex D}}, T :: 'A_' ::=
    | N       :: :: Base
    | A (.) B :: :: Para
    | A (+) B :: :: Par
    | A > B   :: :: Seq
    | A + B   :: :: Choice
    | A -> B  :: :: RLimp
    | B <- A  :: :: LLimp
    | A -o B  :: :: Limp
    | ( A )   :: :: Paren
    | h( A ) ::  :: HParen
    {{tex [[A]] }}

  p :: 'Pat_' ::=
    | -  :: :: H
    | x  :: :: Var
    | p1 (+) p2 :: :: Par
    | p1 (.) p2 :: :: Para
    | p1 > p2   :: :: Seq
    | p1 + p2   :: :: Choice
    | ( p )     :: :: Parens

  t, s :: 'Term_' ::=
    | n           :: :: Const
    {{tex \mathsf{n} }}
    | x           :: :: Var
    | t1 (.) t2   :: :: Para
    | let p = t1 in t2 :: :: Let
    {{tex \mathsf{let}\,[[p]] = [[t1]]\,\mathsf{in}\,[[t2]] }}
    | t1 > t2     :: :: Seq
    | t1 + t2     :: :: Choice
    | t1 (+) t2   :: :: Par
    {{tex [[t1]] \oplus [[t2]] }}
    | dist x11 , x12 with x1 in t :: :: Dist
    {{tex \mathsf{dist}\,[[x11]],[[x12]]\,\mathsf{with}\,[[x1]]\,\mathsf{in}\,[[t]] }}
    | contract x11 , x12 with x1 in t :: :: Contacts
    {{tex \mathsf{contract}\,[[x11]],[[x12]]\,\mathsf{with}\,[[x1]]\,\mathsf{in}\,[[t]] }}
    | \ x . t     :: :: LFun
    {{tex \lambda [[x]] . [[t]] }}
    | \l x . t    :: :: RLFun
    {{tex \lambda_l [[x]] .  [[t]] }}
    | \r x . t    :: :: LLFun
    {{tex \lambda_r [[x]] .  [[t]] }}    
    | t1 t2       :: :: LApp
    | appr t1 t2  :: :: RLApp
    {{tex \mathsf{app}_r\,[[t1]]\,[[t2]] }}
    | appl t1 t2  :: :: LLApp
    {{tex \mathsf{app}_l\,[[t1]]\,[[t2]] }}
    | ( t )       :: :: Parens
    | [ t1 / x ] t2 :: M :: Sub

  G {{ tex \Gamma }}, D {{tex \Delta }} :: G_ ::=                 
    | *                   ::   :: emptyCtx     
    {{tex \cdot }}
    | A                   ::   :: hyp
    | x : A               ::   :: vn
    | G | G'              ::   :: append
    {{tex [[G]] \mid [[G']] }}
    | G , G'              ::   :: append1
    | G ; G'              ::   :: append2
    | G1 . G2             ::   :: append3
    {{tex [[G1]] . [[G2]] }}
    | ( G )               ::   :: parens
    | h( G )              ::   :: hparens
    {{tex [[G]] }}

  P {{ tex \Phi }}, S {{tex \Psi }} :: P_ ::=                 
    | *                   ::   :: emptyCtx     
    {{tex \cdot }}
    | t : A               ::   :: vn
    | P , P'              ::   :: append1
    | ( P )               ::   :: parens
    | h( P )              ::   :: hparens
    {{tex [[P]] }}
    | [ t / x ] P         :: M :: Sub
    | let p = t1 in P     :: M :: Let
    {{tex \mathsf{let}\,[[p]] = [[t1]]\,\mathsf{in}\,[[P]] }}

  terminals :: 'terminals_' ::=
    | (.) :: :: Para
    {{tex \odot}}
    | (+) :: :: Par
    {{tex \oplus}}    
    | > :: :: Seq
    {{tex \rhd}}
    | + :: :: Choice
    {{tex \sqcup }}
    |  ->                 ::   :: arrow
    {{tex \rightharpoonup }}
    |  <-                 ::   :: arrow2
    {{tex \leftharpoonup }}
    |  -o                 ::   :: arrow3
    {{tex \multimap }}
    |  o-o                 ::   :: arrow4
    {{tex \multimapboth }}        
    | |-                  ::   :: turnstile
    {{tex \vdash }}
    | |~                  ::   :: ndash
    {{tex \not \vdash }}    
    | succ                ::   :: succ
    {{tex \mathsf{succ} }}
    | ~                   ::   :: cons
    {{tex \sim }}
    | ~U                  ::   :: conv
    {{tex \sim_U }}    
    | elem                ::   :: elem
    {{tex \in }}
    | ~>                  ::   :: red
    {{tex \rightsquigarrow }}
    | box        :: :: box
    {{tex \mathsf{box} }}
    | unbox        :: :: unbox
    {{tex \mathsf{unbox} }}
    | fst        :: :: fst
    {{tex \mathsf{fst} }}
    | snd        :: :: snd
    {{tex \mathsf{snd} }}
    | !=         :: :: Neq
    {{tex \neq }}
    | nin        :: :: Nin
    {{tex \not\in }}

  formula :: 'formula_' ::=
    | judgement           ::   :: judgement
    | formula1 && formula2 ::  :: Quad
    {{tex [[formula1]] \quad [[formula2]] }}
    | ( formula )         :: S :: parens
    {{tex [[formula]] }}
    | x nin FV( P )       :: M :: FV
    {{tex [[x]] \not\in \mathsf{FV}([[P]]) }}
    | x nin FV( t )       :: M :: FV2
    {{tex [[x]] \not\in \mathsf{FV}([[t]]) }}
    | x : A nin G         :: M :: InCtx
    | D1 != D2            :: M :: NeqC    
    
defns
  Typing :: '' ::=

defn
  G1 |- G2 :: :: ctxm :: 'C_'
  {{com Context Morphisms }}
  {{tex [[G1]] \vdash [[G2]] }} by

  ------ :: id
  G |- G

  G1 |- G2 && G2 |- G3
  -------------------- :: c
  G1 |- G3

  -------------------------------- :: a1
  (G1 | G2) | G3 |- G1 | (G2 | G3)

  ------------ :: m1
  * | G2 |- G2

  ------------ :: m2
  G1 | * |- G1  

 ------------------------------------------ :: e1L
 h(G1 | h(A,B)) | G2 |- h(G1 | h(B,A)) | G2

 ------------------------------------------ :: e2L
 h(G1 | h(A.B)) | G2 |- h(G1 | h(B.A)) | G2

 ------------------------------------- :: c1L
 h(G1 | A) | G2 |- h(G1 | h(A.A)) | G2

 ------------------------------------- :: c2L
 h(G1 | h(A.A)) | G2 |- h(G1 | A) | G2

 ---------------------------------------------------------- :: d1L
 h(G1 | h(A;(D1.D2))) | G2 |- h(G1 | h((A;D1).(A;D2))) | G2

 ---------------------------------------------------------- :: d2L
 h(G1 | h((A;D1).(A;D2))) | G2 |- h(G1 | h(A;(D1.D2))) | G2

 ---------- :: Weak
 G | A |- G

defn
  P1 |- P2 :: :: cctxm :: 'CC_'
  {{com Context Morphisms }}
  {{tex [[P1]] \vdash [[P2]] }} by

  ------ :: id
  P |- P

  P1 |- P2 && P2 |- P3
  -------------------- :: c
  P1 |- P3

  -------------------------------- :: a1
  (P1, P2), P3 |- P1, (P2, P3)

  ------------ :: m1
  *, P2 |- P2

  ------------ :: m2
  P1, * |- P1

  ---------------------------------------------------------- :: e
  h(P1, h(x1 : A,x2 : B)), P2 |- h(P1, h(x2 : B,x1 : A)), P2

defn
 G |- T :: :: vtl :: 'AT_'
 {{com Valid Attack Trees }}
 {{tex [[G]] \vdash [[T]] }} by

 ------ :: var
 T |- T

 ------ :: node
 * |- N

 G |- T1 && D |- T2
 ------------------ :: paraI
 G,D |- T1 (.) T2

 G |- T1 && D |- T2
 ------------------ :: choiceI
 G.D |- T1 + T2

 G |- T1 && D |- T2
 ------------------ :: seqI
 G;D |- T1 > T2

defn
 G |- A :: :: atl :: 'L_'
 {{com Attack Tree Logic (ATL) }}
 {{tex [[G]] \vdash [[A]] }} by
    
 ------ :: var
 B |- B

 ------ :: node
 * |- N

 G1 |- G2 && G2 |- A
 ----------------------- :: Ctx
 G1 |- A

 G |- A && D |- B
 ---------------- :: paraI
 G,D |- A (.) B

 G |- A && D |- B
 ---------------- :: choiceI
 G.D |- A + B

 G |- A && D |- B
 ---------------- :: seqI
 G;D |- A >  B

 G |- A (.) B && h(D1 | h(A,B)) | D2 |- C
 ---------------------------------------- :: paraE
 h(D1 | G) | D2 |- C

 G |- A + B && h(D1 | h(A.B)) | D2 |- C
 -------------------------------------- :: choiceE
 h(D1 | G) | D2 |- C

 G |- A > B && h(D1 | h(A;B)) | D2 |- C
 -------------------------------------- :: seqE
 h(D1 | G) | D2 |- C

 G,A |- B
 ----------- :: limpI
 G |- A -o B

 G |- A -o B && D |- A
 --------------------- :: limpE
 G,D |- B

 G;A |- B
 ----------- :: RlimpI
 G |- A -> B

 G |- A -> B && D |- A
 ------------------------------- :: RlimpE
 G;D |- B

 A;G |- B
 ----------- :: LlimpI
 G |- B <- A

 G |- B <- A && D |- A
 --------------------- :: LlimpE
 D;G |- B

defn
 G |- t : T :: :: att :: 'ATT_'
 {{com Valid Attack Tree Type Theory (ATTT) }}
 {{tex [[G]] \vdash [[t]] : [[T]] }} by
    
 -------------- :: var
 x : T |- x : T

 ---------- :: node
 * |- n : N
 
 G |- t1 : T1 && D |- t2 : T2
 -------------------------- :: paraI
 G,D |- t1 (.) t2 : T1 (.) T2

 G |- t1 : T1 && D |- t2 : T2
 -------------------------- :: choiceI
 G.D |- t1 + t2 : T1 + T2

 G |- t1 : T1 && D |- t2 : T2
 ---------------------------- :: seqI
 G;D |- t1 > t2 : T1 >  T2

defn
 G |- t : A :: :: atv :: 'T_'
 {{com Attack Tree Type Theory (ATTT) }}
 {{tex [[G]] \vdash [[t]] : [[A]] }} by
    
 -------------- :: var
 x : B |- x : B

 ---------- :: node
 * |- n : N

 h(G1 | h(x1 : A, x2 : B)) | G2 |- t : C
 --------------------------------------- :: ex1
 h(G1 | h(x2 : A, x1 : B)) | G2 |- t : C

 h(G1 | h(x1 : A. x2 : B)) | G2 |- t : C
 --------------------------------------- :: ex2
 h(G1 | h(x2 : A. x1 : B)) | G2 |- t : C

 G1 | G2 |- t : B && x nin FV(t)
 ----------------------------------- :: weak
 h(G1 | x : A) | G2 |- t : B

 h(G1 | h(x1 : A;(D1.D2))) |- t : d && x2 nin FV(t)
 -------------------------------------------------- :: dist1
 h(G1 | h((x1 : A;D1).(x2 : A;D2))) |- t : d

 (h(G1 | h((x11 : A;D1).(x12 : A;D2))) | G2 |- t : d && D1 != *) && D2 != *
 -------------------------------------------------------------------------- :: dist2
 h(G1 | h(x1 : A;(D1.D2))) |- dist x11,x12 with x1 in t : d

 h(G1 | x1 : A) | G2 |- t : B && x2 nin FV(t)
 -------------------------------------------- :: contract1
 h(G1 | (x1 : A.x2 : A)) | G2 |- t : B

 h(G1 | h(x1 : A.x2 : A)) | G2 |- t : B
 ---------------------------------------------------- :: contract2
 h(G1 | x : A) | G2 |- contract x1,x2 with x in t : B

 G |- t1 : A && D |- t2 : B
 -------------------------- :: paraI
 G,D |- t1 (.) t2 : A (.) B

 G |- t1 : A && D |- t2 : B
 -------------------------- :: choiceI
 G.D |- t1 + t2 : A + B

 G |- t1 : A && D |- t2 : B
 -------------------------- :: seqI
 G;D |- t1 > t2 : A >  B

 G |- t1 : A (.) B && h(D1 | h(x1 : A,x2 : B)) | D2 |- t2 : C
 ------------------------------------------------------------ :: paraE
 h(D1 | G) | D2 |- let (x1 (.) x2) = t1 in t2 : C

 G |- t1 : A + B && h(D1 | h(x1 : A.x2 : B)) | D2 |- t2 : C
 ---------------------------------------------------------- :: choiceE
 h(D1 | G) | D2 |- let (x1 + x2) = t1 in t2 : C

 G |- t1 : A > B && h(D1 | h(x1 : A;x2 : B)) | D2 |- t2 : C
 ---------------------------------------------------------- :: seqE
 h(D1 | G) | D2 |- let (x1 > x2) = t1 in t2 : C

 G,x : A |- t : B
 ------------------ :: limpI
 G |- \x.t : A -o B

 G |- t1 : A -o B && D |- t2 : A
 ------------------------------- :: limpE
 G,D |- t1 t2 : B

 G;x : A |- t : B
 ---------------------- :: RlimpI
 G |- \r x . t : A -> B

 G |- t1 : A -> B && D |- t2 : A
 ------------------------------- :: RlimpE
 G;D |- appr t1 t2 : B

 x : A;G |- t : B
 ---------------------- :: LlimpI
 G |- \l x . t : B <- A

 G |- t1 : B <- A && D |- t2 : A
 ------------------------------- :: LlimpE
 D;G |- appl t1 t2 : B

defn
 t1 ~> t2 :: :: red :: 'R_'
 by 

% Beta-reductions:

 ----------------------------------------------------- :: paraBeta
 let (x1 (.) x2) = t1 (.) t2 in t3 ~> [t1/x1][t2/x2]t3

 ----------------------------------------------------- :: choiceBeta
 let (x1 + x2) = t1 + t2 in t3 ~> [t1/x1][t2/x2]t3

 ----------------------------------------------------- :: seqBeta
 let (x1 > x2) = t1 > t2 in t3 ~> [t1/x1][t2/x2]t3

 ---------------------- :: beta
 (\x.t2) t1 ~> [t1/x]t2

 ----------------------------- :: betar
 appr (\r x.t2) t1 ~> [t1/x]t2

 ----------------------------- :: betal
 appl (\l x.t2) t1 ~> [t1/x]t2

% Commuting Conversions:

 ------------------------------------------------------------------------------------------------------------ :: paraCC
 let (x1 (.) x2) = (let (y1 (.) y2) = t1 in t2) in t3 ~> let (y1 (.) y2) = t1 in (let (x1 (.) x2) = t2 in t3)

 -------------------------------------------------------------------------------------------------------- :: paraCCC
 let (x1 (.) x2) = (let (y1 + y2) = t1 in t2) in t3 ~> let (y1 + y2) = t1 in (let (x1 (.) x2) = t2 in t3)

 -------------------------------------------------------------------------------------------------------- :: paraSCC
 let (x1 (.) x2) = (let (y1 > y2) = t1 in t2) in t3 ~> let (y1 > y2) = t1 in (let (x1 (.) x2) = t2 in t3)

 ---------------------------------------------------------------------------------------------------- :: choiceCC
 let (x1 + x2) = (let (y1 + y2) = t1 in t2) in t3 ~> let (y1 + y2) = t1 in (let (x1 + x2) = t2 in t3)

 -------------------------------------------------------------------------------------------------------- :: choicePCC
 let (x1 + x2) = (let (y1 (.) y2) = t1 in t2) in t3 ~> let (y1 (.) y2) = t1 in (let (x1 + x2) = t2 in t3)

 ---------------------------------------------------------------------------------------------------- :: choiceSCC
 let (x1 + x2) = (let (y1 > y2) = t1 in t2) in t3 ~> let (y1 > y2) = t1 in (let (x1 + x2) = t2 in t3)

 ---------------------------------------------------------------------------------------------------- :: seqCC
 let (x1 > x2) = (let (y1 > y2) = t1 in t2) in t3 ~> let (y1 > y2) = t1 in (let (x1 > x2) = t2 in t3)

 -------------------------------------------------------------------------------------------------------- :: seqPCC
 let (x1 > x2) = (let (y1 (.) y2) = t1 in t2) in t3 ~> let (y1 (.) y2) = t1 in (let (x1 > x2) = t2 in t3)

 ---------------------------------------------------------------------------------------------------- :: seqCCC
 let (x1 > x2) = (let (y1 + y2) = t1 in t2) in t3 ~> let (y1 + y2) = t1 in (let (x1 > x2) = t2 in t3)

 ------------------------------------------------------------------ :: paraACC
 (let (x1 (.) x2) = t1 in t2) t3 ~> let (x1 (.) x2) = t1 in (t2 t3)

 -------------------------------------------------------------- :: choiceACC
 (let (x1 + x2) = t1 in t2) t3 ~> let (x1 + x2) = t1 in (t2 t3)

 ------------------------------------------------------------------ :: seqACC
 (let (x1 > x2) = t1 in t2) t3 ~> let (x1 > x2) = t1 in (t2 t3)

defn
 G |-F P :: :: fill :: 'F_'    
 {{tex [[G]] \vdash [[P]] }} by
    
 --------------- :: var
 x : B |-F x : B

 (G1 |- G2 && G2 |-F P2) && P2 |- P1
 ----------------------------------- :: ctx
 G1 |-F P1

 G2 |-F P1,t : A,P3 && h(G1 | x : A) | G3 |-F P2
 ----------------------------------------------- :: cut
 h(G1 | G2) | G3 |-F P1,[t/x]P2,P3

 h(G1 | h(x1 : A,x2 : B)) | G2 |-F P
 ----------------------------------------------------- :: paraL
 h(G1 | y : A (.) B) | G2 |-F let (x1 (.) x2) = y in P

 G |-F t1 : A,P1 && D |-F t2 : B,P2
 ---------------------------------- :: paraR
 G,D |-F t1 (.) t2 : A (.) B,P1,P2

 h(G1 | h(x1 : A;x2 : B)) | G2 |-F P
 ------------------------------------------------- :: seqL
 h(G1 | y : A > B) | G2 |-F let (x1 > x2) = y in P

 G |-F t1 : A,P1 && D |-F t2 : B,P2
 ---------------------------------- :: seqR
 G;D |-F t1 > t2 : A > B,P1,P2

 G2 |-F t1 : A, P1 && h(G1 | x : B) | G3 |-F P2
 ---------------------------------------------- :: limpL
 h(G1 | h(y : A -o B,G2)) | G3 |-F P1,[y t1/x]P2

 G,x : A |-F t : B, P && x nin FV(P)
 ----------------------------------- :: limpR
 G |-F \x.t : A -o B,P

 G2 |-F t1 : A, P1 && h(G1 | x : B) | G3 |-F P2
 ----------------------------------------------- :: RlimpL
 h(G1 | h(G2,y : A -> B)) | G3 |-F P1,[y t1/x]P2

 G;x : A |-F t : B,P && x nin FV(P)
 ---------------------------------- :: RlimpR
 G |-F \r x . t : A -> B, P

 G2 |-F t1 : A, P1 && h(G1 | x : B) | G3 |-F P2
 ----------------------------------------------- :: LlimpL
 h(G1 | h(y : A <- B,G2)) | G3 |-F P1,[y t1/x]P2

 x : A;G |-F t : B,P && x nin FV(P)
 --------------------------------- :: LlimpR
 G |-F \l x . t : B <- A, P

 G |-F P1 , t1 : A, t2 : B,P2
 ------------------------------ :: parR
 G |-F P1,t1 (+) t2 : A (+) B,P2

 G1 | x1 : A |-F P1 && x2 : B | G2 |-F P2
 ------------------------------------------------------------------------------- :: parL
 h(G1 | z : A (+) B) | G2 |-F (let x1 (+) - = z in P1), (let - (+) x2 = z in P2)