\documentclass{llncs}

\usepackage{wrapfig}
\usepackage{amssymb,amsmath}
\usepackage{cmll}
\usepackage{stmaryrd}
\usepackage{todonotes}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[barr]{xy}
\usepackage{mdframed}
\usepackage{thmtools, thm-restate}
\usepackage{enumitem}

%% This renames Barr's \to to \mto.  This allows us to use \to for imp
%% and \mto for a inline morphism.
\let\mto\to
\let\to\relax
\newcommand{\to}{\rightarrow}

% Commands that are useful for writing about type theory and programming language design.
%% \newcommand{\case}[4]{\text{case}\ #1\ \text{of}\ #2\text{.}#3\text{,}#2\text{.}#4}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\normto}[0]{\rightsquigarrow^{!}}
\newcommand{\join}[0]{\downarrow}
\newcommand{\redto}[0]{\rightsquigarrow}
\newcommand{\nat}[0]{\mathbb{N}}
\newcommand{\fun}[2]{\lambda #1.#2}
\newcommand{\CRI}[0]{\text{CR-Norm}}
\newcommand{\CRII}[0]{\text{CR-Pres}}
\newcommand{\CRIII}[0]{\text{CR-Prog}}
\newcommand{\subexp}[0]{\sqsubseteq}
%% Must include \usepackage{mathrsfs} for this to work.
\newcommand{\powerset}[0]{\mathscr{P}}

\date{}

% Cat commands.
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\catop}[1]{\cat{#1}^{\mathsf{op}}}
\newcommand{\Hom}[3]{\mathsf{Hom}_{\cat{#1}}(#2,#3)}
\newcommand{\limp}[0]{\multimap}
\newcommand{\dial}[0]{\mathsf{Dial_3}(\mathsf{Sets})}
\newcommand{\dialSets}[1]{\mathsf{Dial_{#1}}(\mathsf{Sets})}
\newcommand{\dcSets}[1]{\mathsf{DC_{#1}}(\mathsf{Sets})}
\newcommand{\sets}[0]{\mathsf{Sets}}
\newcommand{\obj}[1]{\mathsf{Obj}(#1)}
\newcommand{\mor}[1]{\mathsf{Mor(#1)}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\lett}[0]{\mathsf{let}\,}
\newcommand{\inn}[0]{\,\mathsf{in}\,}
\newcommand{\cur}[1]{\mathsf{cur}(#1)}
\newcommand{\curi}[1]{\mathsf{cur}^{-1}(#1)}

\newenvironment{changemargin}[2]{%
  \begin{list}{}{%
    \setlength{\topsep}{0pt}%
    \setlength{\leftmargin}{#1}%
    \setlength{\rightmargin}{#2}%
    \setlength{\listparindent}{\parindent}%
    \setlength{\itemindent}{\parindent}%
    \setlength{\parsep}{\parskip}%
  }%
  \item[]}{\end{list}}

%% % Theorems
%% \newtheorem{theorem}{Theorem}
%% \newtheorem{lemma}[theorem]{Lemma}
%% \newtheorem{fact}[theorem]{Fact}
%% \newtheorem{corollary}[theorem]{Corollary}
%% \newtheorem{definition}[theorem]{Definition}
%% \newtheorem{remark}[theorem]{Remark}
%% \newtheorem{proposition}[theorem]{Proposition}
%% \newtheorem{notn}[theorem]{Notation}
%% \newtheorem{observation}[theorem]{Observation}

%% Ott
\input{indexed-atll-ott}
\input{atll-ott}
\input{oll-ott}
\input{aterms-ott}
%% \renewcommand{\IATLLdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\IATLLdrulename{#4}}}
%% \renewcommand{\IATLLdrulename}[1]{#1}
%% \renewcommand{\IATLLdruleTXXvarName}{\text{id}_{\odot}}
%% \renewcommand{\IATLLdruleTXXparaName}{\odot}
%% \renewcommand{\IATLLdruleTXXseqName}{\rhd}
%% \renewcommand{\IATLLdruleTXXchoiceName}{\sqcup}

%% \renewcommand{\IATLLdruleEXXvarName}{\text{id}_{\odot}}
%% \renewcommand{\IATLLdruleEXXvarCName}{\text{id}_{\rhd}}
%% \renewcommand{\IATLLdruleEXXvarCCName}{\text{id}_{\sqcup}}
%% \renewcommand{\IATLLdruleEXXdistParaOneName}{\text{dis}_{\odot_1}}
%% \renewcommand{\IATLLdruleEXXdistSeqOneName}{\text{dis}_{\rhd_1}}
%% \renewcommand{\IATLLdruleEXXdistParaTwoName}{\text{dis}_{\odot_2}}
%% \renewcommand{\IATLLdruleEXXdistSeqTwoName}{\text{dis}_{\rhd_2}}
%% \renewcommand{\IATLLdruleEXXparaIName}{\odot_I}
%% \renewcommand{\IATLLdruleEXXparaEName}{\odot_E}
%% \renewcommand{\IATLLdruleEXXseqIName}{\rhd_I}
%% \renewcommand{\IATLLdruleEXXseqEName}{\rhd_E}
%% \renewcommand{\IATLLdruleEXXexPName}{\text{sym}_\odot}
%% \renewcommand{\IATLLdruleEXXexCName}{\text{sym}_\sqcup}
%% \renewcommand{\IATLLdruleEXXimpIName}{\multimap_I}
%% \renewcommand{\IATLLdruleEXXimpEName}{\multimap_E}
%% \renewcommand{\ATLLdruleEXXcompName}{\text{comp}_\multimap}

%% \renewcommand{\ATLLdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\ATLLdrulename{#4}}}
%% \renewcommand{\ATLLdrulename}[1]{#1}
%% \renewcommand{\ATLLdruleTXXvarName}{\text{id}_{\odot}}
%% \renewcommand{\ATLLdruleTXXparaName}{\odot}
%% \renewcommand{\ATLLdruleTXXseqName}{\rhd}
%% \renewcommand{\ATLLdruleTXXchoiceName}{\sqcup}

%% \renewcommand{\ATLLdruleEXXvarName}{\text{id}_{\odot}}
%% \renewcommand{\ATLLdruleEXXvarCName}{\text{id}_{\rhd}}
%% \renewcommand{\ATLLdruleEXXvarCCName}{\text{id}_{\sqcup}}
%% \renewcommand{\ATLLdruleEXXdistParaOneName}{\text{dis}_{\odot_1}}
%% \renewcommand{\ATLLdruleEXXdistSeqOneName}{\text{dis}_{\rhd_1}}
%% \renewcommand{\ATLLdruleEXXdistParaTwoName}{\text{dis}_{\odot_2}}
%% \renewcommand{\ATLLdruleEXXdistSeqTwoName}{\text{dis}_{\rhd_2}}
%% \renewcommand{\ATLLdruleEXXparaIName}{\odot_I}
%% \renewcommand{\ATLLdruleEXXparaEName}{\odot_E}
%% \renewcommand{\ATLLdruleEXXseqIName}{\rhd_I}
%% \renewcommand{\ATLLdruleEXXseqEName}{\rhd_E}
%% \renewcommand{\ATLLdruleEXXexPName}{\text{sym}_\odot}
%% \renewcommand{\ATLLdruleEXXexCName}{\text{sym}_\sqcup}
%% \renewcommand{\ATLLdruleEXXimpIName}{\multimap_I}
%% \renewcommand{\ATLLdruleEXXimpEName}{\multimap_E}
%% \renewcommand{\ATLLdruleEXXweakCName}{\text{wk}_\sqcup}
%% \renewcommand{\ATLLdruleEXXweakPName}{\text{wk}_\odot}
%% \renewcommand{\ATLLdruleEXXweakSName}{\text{wk}_\rhd}
%% \renewcommand{\ATLLdruleEXXchoiIName}{\sqcup_I}
%% \renewcommand{\ATLLdruleEXXchoiEName}{\sqcup_E}
%% \renewcommand{\IATLLdruleEXXchoiIName}{\sqcup_I}
%% \renewcommand{\IATLLdruleEXXchoiEName}{\sqcup_E}
%% \renewcommand{\ATLLdruleEXXdupName}{\text{dup}_\sqcup}
%% \renewcommand{\IATLLdruleEXXdupName}{\text{dup}_\sqcup}
%% \renewcommand{\ATLLdruleEXXcontName}{\text{cont}_\sqcup}
%% \renewcommand{\IATLLdruleEXXcontName}{\text{cont}_\sqcup}

%% \renewcommand{\OLLdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\OLLdrulename{#4}}}
%% \renewcommand{\OLLdrulename}[1]{#1}
%% \renewcommand{\OLLdrulevarName}{\text{id}_{\odot}}
%% \renewcommand{\OLLdrulevarCName}{\text{id}_{\rhd}}
%% \renewcommand{\OLLdruleparaIName}{\odot_I}
%% \renewcommand{\OLLdruleparaEName}{\odot_E}
%% \renewcommand{\OLLdruleseqIName}{\rhd_I}
%% \renewcommand{\OLLdruleseqEName}{\rhd_E}
%% \renewcommand{\OLLdruleexName}{\text{sym}_\odot}
%% \renewcommand{\OLLdruleimpIName}{\multimap_I}
%% \renewcommand{\OLLdruleimpEName}{\multimap_E}
%% \renewcommand{\OLLdruleTopName}{\top}
%% \renewcommand{\OLLdruleconjIName}{\times_I}
%% \renewcommand{\OLLdruleconjEOneName}{\times_{E_1}}
%% \renewcommand{\OLLdruleconjETwoName}{\times_{E_2}}
  
\begin{document}

\title{????}

\author{Harley Eades III}
\institute{Computer Science\\Augusta University \\ \href{mailto:heades@augusta.edu}{harley.eades@gmail.com}}

\maketitle 

\begin{abstract}
  TODO
\end{abstract}

\section{Introduction}
\label{sec:introduction}
%% \input{intro-output}

\section{A Quaternary Semantics for SAND Attack Trees}
\label{sec:a_quaternary_semantics_for_sand_attack_trees}
\input{quaternary-semantics-output}
% section a_ternary_semantics_for_sand_attack_trees (end)

\section{Lineale Semantics for SAND Attack Trees}
\label{sec:lineale_semantics_for_sand_attack_trees}
\input{postal-semantics-output}
% section postal_semantics_for_sand_attack_trees (end)


%% \section{A Brief Introduction to Ordered Linear Logic}
%% \label{sec:a_brief_introduction_to_ordered_linear_logic}
%% \input{oll-output}
%% % section a_brief_introduction_to_ordered_linear_logic (end)


%% \section{Attack Trees without Costs}
%% \label{sec:attack_trees_without_costs}
%% \input{attack-trees-output}
%% % section attack_trees_without_costs (end)

%% \section{Attack Trees with Costs}
%% \label{sec:attack_trees_with_costs}
%% \input{indexed-atll-output}
% section attack_trees_with_costs (end)

%% \section{Related and Future Work}
%% \label{sec:related_work}
%% The following summarizes related work and proposes a few open
%% problems:
%% \begin{itemize}
%% \item Attack trees with sequential conjunction were first proposed by
%%   Jhawar et al.~\cite{Jhawar:2015}.  They found their attack trees in
%%   sets of series-parallel graphs.  The foundation given here offers a
%%   new perspective by founding attack trees in linear logic.

%% \item Kordy et al.~\cite{Kordy2010,Kordy:2012} proposed that attack
%%   trees be modeled in propositional logic.  Their work provided many
%%   insights into how to use logic to model attack trees, but
%%   propositional logic does not enforce the concurrency aspect of
%%   attack trees.  This is regained in ATLL by using linear logic.
%%   There is a rich amount of research that has gone into giving linear
%%   logic a game semantics \cite{Abramsky1999}.  I propose an open
%%   problem, in the spirit of Kordy et al.~\cite{Kordy2010} \textbf{can
%%     we use a game semantics of linear logic to model attack trees?}
%%   This would provide the same benefits as their work, but with the
%%   resource semantics left intact.
  
%% \item Samarji et al.~\cite{Samarji2013} propose that graph based
%%   attack-defense models can be automatically constructed using and
%%   extension of John McCarthy's situation calculus.  Originally the
%%   situation calculus did not contain the ability to model concurrent
%%   attacks, but has since been updated to allow the modeling of
%%   concurrency \cite{Reiter96naturalactions,Pinto:1994:TRS:921488}. An
%%   additional sort had to be added to the situation calculus called
%%   $\mathsf{concurrent}$ whose inhabitants are all concurrent actions.
%%   This is in contrast to linear logic where concurrency and state
%%   change are innate properties of the logic.  Thus, linear logic is
%%   more fundamental than the situation calculus.  This shows up already
%%   in ATLL which correctly models attack trees in a simpler system --
%%   propositional linear logic -- than the situation calculus --
%%   first-order logic.  Furthermore, this opens up an interesting
%%   questions, \textbf{can one model the situation calculus in first-order
%%   linear logic?} This needs to be explored.
%% \end{itemize}
%% \noindent
%% \textbf{Future work.} My students and I are working on designing and
%% implementing a term-assignment to the fully general version of Indexed
%% ATLL.  Under the Curry-Howard-Lambek correspondence this will produce
%% a statically-typed functional programming language for specifying and
%% reasoning about attack trees.  We hope to then study the feasibility
%% of constructing a means of automatically constructing and reasoning
%% about attack trees in a proof producing manner.  Finally, we are
%% looking into if it is possible to use current graphical models of
%% linear logic in string diagrams and proof nets to reason about attack
%% trees graphically.
% section related_work (end)

\bibliographystyle{plain}
\bibliography{ref}

\appendix

\section*{Appendix}
\label{sec:appendix}

%% \section{The Full Specification of Indexed ATLL}
%% \label{subsec:the_full_specification_of_indexed_atll}
%% \input{full-indexed-atll-output}
% section the_full_specification_of_indexed_atll (end)

%% \subsection{SSG Semantics}
%% \label{subsec:ssg_semantics}
%% \input{appendix-SSG-monoidal}
% subsection ssg_semantics (end)

% section appendix (end)



\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

