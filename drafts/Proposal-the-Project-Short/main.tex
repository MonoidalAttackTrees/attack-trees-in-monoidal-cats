\documentclass{sigplanconf}

\usepackage{amssymb,amsmath,amsthm}
\usepackage{cmll}
\usepackage{stmaryrd}
\usepackage{todonotes}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[barr]{xy}

%% This renames Barr's \to to \mto.  This allows us to use \to for imp
%% and \mto for a inline morphism.
\let\mto\to
\let\to\relax
\newcommand{\to}{\rightarrow}

% Commands that are useful for writing about type theory and programming language design.
%% \newcommand{\case}[4]{\text{case}\ #1\ \text{of}\ #2\text{.}#3\text{,}#2\text{.}#4}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\normto}[0]{\rightsquigarrow^{!}}
\newcommand{\join}[0]{\downarrow}
\newcommand{\redto}[0]{\rightsquigarrow}
\newcommand{\nat}[0]{\mathbb{N}}
\newcommand{\fun}[2]{\lambda #1.#2}
\newcommand{\CRI}[0]{\text{CR-Norm}}
\newcommand{\CRII}[0]{\text{CR-Pres}}
\newcommand{\CRIII}[0]{\text{CR-Prog}}
\newcommand{\subexp}[0]{\sqsubseteq}
%% Must include \usepackage{mathrsfs} for this to work.
\newcommand{\powerset}[0]{\mathscr{P}}

\date{}

% Cat commands.
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\catop}[1]{\cat{#1}^{\mathsf{op}}}
\newcommand{\Hom}[3]{\mathsf{Hom}_{\cat{#1}}(#2,#3)}
\newcommand{\limp}[0]{\multimap}
\newcommand{\dial}[0]{\mathsf{Dial_3}(\mathsf{Sets})}
\newcommand{\dialSets}[1]{\mathsf{Dial_{#1}}(\mathsf{Sets})}
\newcommand{\dcSets}[1]{\mathsf{DC_{#1}}(\mathsf{Sets})}
\newcommand{\sets}[0]{\mathsf{Sets}}
\newcommand{\obj}[1]{\mathsf{Obj}(#1)}
\newcommand{\mor}[1]{\mathsf{Mor(#1)}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\lett}[0]{\mathsf{let}\,}
\newcommand{\inn}[0]{\,\mathsf{in}\,}
\newcommand{\cur}[1]{\mathsf{cur}(#1)}
\newcommand{\curi}[1]{\mathsf{cur}^{-1}(#1)}

\newenvironment{changemargin}[2]{%
  \begin{list}{}{%
    \setlength{\topsep}{0pt}%
    \setlength{\leftmargin}{#1}%
    \setlength{\rightmargin}{#2}%
    \setlength{\listparindent}{\parindent}%
    \setlength{\itemindent}{\parindent}%
    \setlength{\parsep}{\parskip}%
  }%
  \item[]}{\end{list}}

% Theorems
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{notn}[theorem]{Notation}
\newtheorem{observation}[theorem]{Observation}

%% Ott
\input{atrees-ott}
\input{type-level-Lina-ott}

\begin{document}

\conferenceinfo{PLAS '16}{October 24, 2016, Vienna, Austria}
\copyrightyear{2016}
\copyrightdata{}
\copyrightdoi{}
\titlebanner{}

\title{Short Paper: Proposing a New Foundation of Attack Trees in Monoidal Categories}

\authorinfo{Harley Eades III}{Computer Science\\Augusta University}{heades@augusta.edu}

\maketitle 

\begin{abstract}
  This short paper introduces a new research direction studying at the
  intersection of threat analysis using attack trees and interactive
  theorem proving using linear logic.  Currently, the project has
  developed a new semantics of attack trees in dialectica spaces, a
  well-known model of intuitionistic linear logic, which offers a new
  branching operator to attack trees.  Then by exploiting the
  Curry-Howard-Lambek correspondence the project seeks to develop a
  new domain-specific linear functional programming language called
  Lina -- for Linear Threat Analysis -- for specifying and reasoning
  about attack trees.
\end{abstract}

\category{D.3.3}{Programming Languages}
{Language Constructs and Features}
[Control structures]
\terms
TODO
\keywords
TODO

\section{Introduction}
\label{sec:introduction}

What do propositional logic, multisets, directed acyclic graphs,
source sink graphs (or parallel-series pomsets), Petri nets, and
Markov processes all have in common?  They are all mathematical models
of attack trees -- see the references in
\cite{Kordy:2014a,Jhawar:2015} -- but also, they can all be modeled in
some form of a symmetric monoidal category\footnote{I provide a proof
  that the category of source sink graphs is monoidal in
  Appendix~\ref{sec:source_sink_graphs_are_symmetric_monoidal}.}
\cite{Tzouvaras:1998,Brown:1991,Fiore:2013,FrancescoAlbasini2010} --
for the definition of a symmetric monoidal category see
Appendix~\ref{sec:symmetric_monoidal_categories}.  Taking things a
little bit further, monoidal categories have a tight correspondence
with linear logic through the beautiful Curry-Howard-Lambek
correspondence \cite{MSC:4439568}.  This correspondence states that
objects of a monoidal category correspond to the formulas of linear
logic and the morphisms correspond to proofs of valid sequents of the
logic.  I propose that attack trees -- in many different flavors -- be
modeled as objects in monoidal categories, and hence, as formulas of
linear logic.

Suppose we are the computer security team of a small hospital, and we
need to asses the potential for an intruder to gain root access of the
all important medical records Unix server.  So we build an attack tree
to asses all of the potential ways one could gain root access to the
server.  Such an attack tree might look something like the following:
\[
  \begin{array}{lll}
    \sqcup\,\text{''Obtain Root Privileges''}\,220\\
    \,\,\,\,\,\,\,(\sqcup\,\text{''Access System Console''}\,130\\
    \,\,\,\,\,\,\,\,\,\,\,\,\,\,\begin{array}{lll}
    (\sqcup\,\text{''Enter Computer Center''}\,110\\
    \,\,\,\,\,\,\,\,\,\,\,\,\,\,\begin{array}{lll}
    (\mathsf{leaf}\,\text{''Break In to Computer Center''}\,80)\\
    (\mathsf{leaf}\,\text{''Unattended Guest''}\,30))\\
    \end{array}\\
    (\mathsf{leaf}\,\text{''Corrupt Operator''}\,20))\\
    \end{array}\\
    \,\,\,\,\,\,\,(\sqcup\,\text{''Obtain Root Password''}\,90\\
    \,\,\,\,\,\,\,\,\,\,\,\,\,\,\begin{array}{lll}
    ([[;]]\,\text{''Guess Password''}\,55\\
    \,\,\,\,\,\,\,\,\,\,\,\,\,\,\begin{array}{lll}
    (\mathsf{leaf}\,\text{''Obtain Password File''}\,15)\\
    (\mathsf{leaf}\,\text{''Encounter Guessable Password''}\,40))\\
    \end{array}\\
    (\sqcup\,\text{''Look Over Sys. Admin. Shoulder''}\,35)\\
    \,\,\,\,\,\,\,\,\,\,\,\,\,\,\begin{array}{lll}
    (\mathsf{leaf}\,\text{''Trojan Horse Root''}\,25)\\
    (\mathsf{leaf}\,\text{''Corrupt Sys. Admin.''}\,10))\\
    \end{array}    
    \end{array}
  \end{array}
\]

Attack trees are a modeling tool, originally proposed by Bruce
Schneier \cite{Schneier:1999}, which are used to assess the threat
potential of a security critical system.  Attack trees have since been
used to analyze the threat potential of many types of security
critical systems, for example, cybersecurity of power grids
\cite{Ten:2007}, wireless networks \cite{Reinhardt:2012}, and many
others.  Attack trees consists of several goals, usually specified in
English prose, for example, ``compromise safe'' or ``obtain
administrative privileges'', where the root is the ultimate goal of
the attack and each node coming off of the root is a refinement of the
main goal into a subgoal.  Then each subgoal can be further refined.
The leaves of an attack tree make up the set of base attacks.
Subgoals can be either disjunctively or conjunctively combined.

%% Extensions Of ATREES:
%%   - Attack nets
%%   - Sequential conjunction
There have been a number of extensions of attack trees to include new
operators on goals.  One such extension recasts attack trees into
attack nets which have all of the benefits of attack trees with the
additional benefit of being able to include the flaw hypothesis model
for penetration testing \cite{McDermott:2001}.  A second extension
adds sequential conjunction of attacks, that is, suppose $A_1$ and
$A_2$ are attacks, then $A_1;A_2$ is the attack obtained by performing
$A_1$, and then executing attack $A_2$ directly after $A_1$ completes
\cite{Jhawar:2015}.

Attack trees for real-world security scenarios can grow to be quite
complex.  The attack tree presented in \cite{Ten:2007} to access the
security of power grids has twenty-nine nodes with sixty counter
measures attached to the nodes throughout the tree.  The details of
the tree spans several pages of appendix.  The attack tree developed
for the border gateway protocol has over a hundred nodes
\cite{Convey:2003}, and the details of the tree spans ten pages.
Manipulating such large trees without a formal semantics can be
dangerous.

%% Semantics of ATREES:
%%   - Boolean logic
%%   - Attack nets (2000)
%%   - Multisets (2006)
%%   - Series-parallel graphs (extension of multisets) (2015)
One of the leading questions the field is seeking to answer is ``what
is an attack tree?''  That is, what is a mathematical foundation of
attack trees? There have been numerous attempts at answering this
question.  For example, attack trees have been based on propositional
logic and De Morgan Algebras
\cite{Kordy:2014,Kordy:2012,Pietre-Cambacedes:2010}, multisets
\cite{Mauw:2006}, Petri nets \cite{McDermott:2001}, tree automata
\cite{Camtepe:2007}, and series parallel graphs
\cite{Jhawar:2015}. \textbf{There is currently no known semantics of
  attack trees based in category theory}.

By far the most intuitive foundation of attack trees is propositional
logic or De Morgan algebras, however, neither of these properly
distinguish between attack trees with repeated subgoals.  If we
consider each subgoal as a \textbf{resource} then the attack tree
using a particular resource twice is different than an attack tree
where it is used only once.  The multiset semantics of attack trees
was developed precisely to provide a resource conscious foundation
\cite{Mauw:2006}. The same can be said for the Petri nets semantics
\cite{McDermott:2001}.  A second benefit of a semantics based in
multisets, Petri nets, and even tree automata is that operators on
goals in attack trees are associated with concurrency operators from
process algebra.  That is, the goals of an attack tree should be
thought of as being run concurrently.  Furthermore, when moving to
these alternate foundations \textbf{the intuitiveness and elegance of
  the propositional logic semantics is lost}.  Lastly, existing work
has focused on specifically what an attack tree is, and has not sought
to understand what the theory of attack trees is.

By modeling attack trees in monoidal categories we obtain a sound
mathematical model, a resource conscious logic for reasoning about
attack trees, and the means of constructing a functional programming
language for defining attack trees (as types), and constructing
semantically valid transformations (as programs) of attack trees.

Linear logic was first proposed by Girard \cite{Girard:1987} and was
quickly realized to be a theory of resources.  In linear logic, every
hypothesis must be used exactly once.  Thus, formulas like $A \otimes
A$ and $A$ are not logically equivalent -- here $\otimes$ is linear
conjunction.  This resource perspective of linear logic has been very
fruitful in computer science and lead to linear logic being a logical
foundation of processes and concurrency where formulas may be
considered as processes.  Treating attack trees as concurrent
processes is not new; they have been modeled by event-based models of
concurrency like Petri nets and partially-ordered multisets (pomsets)
\cite{Jhawar:2015,Mauw:2006}.  In fact, pomsets is a model in which
events (the resources) can be executed exactly once, and thus, has a
relationship with linear logic \cite{Retore:1997}.  However,
connecting linear logic as a theory of attack trees is novel, and
strengthens this perspective.

In this short paper I introduce a newly funded research
project\footnote{This material is based upon work supported by the
  National Science Foundation CRII CISE Research Initiation grant,
  ``CRII:SHF: A New Foundation for Attack Trees Based on Monoidal
  Categories``, under Grant No. 1565557.}  investigating founding
attack trees in monoidal categories, and through the
Curry-Howard-Lambek correspondence deriving a new domain-specific
functional programming language called Lina for Linear Threat
Analysis.  Note that this paper introduces an ongoing research
project, and thus, we do not currently have the complete story, but we
feel that the community will find this project of interest, and the
project would benefit from the feedback of the community.  I begin by
defining an extension -- inspired by our semantics -- of the attack
trees given in \cite{Jhawar:2015} in Section~\ref{sec:attack_trees}.
Then I introduce a new semantics of attack trees in dialectica spaces,
which depends on a novel result on dialectica spaces, in
Section~\ref{sec:concrete_semantics_of_attack_trees_in_dialectica_spaces}.
The final section,
Section~\ref{sec:lina:_a_domain_specific_pl_for_threat_analysis},
discusses Lina and some of the current problems the project seeks to
answer.
% section introduction (end)

\section{Attack Trees}
\label{sec:attack_trees}
In this paper I consider an extension of attack trees with sequential
composition which are due to Jhawar et al. \cite{Jhawar:2015}, but one
of the projects ultimate goals is to extend attack trees with even
more operators driven by our choice of semantics.  The syntax for
attack trees is defined in the following definition.
\begin{definition}
  \label{def:atrees}
  The following defines the syntax of \textbf{Attack Trees} given a set
  of base attacks $b \in \mathsf{B}$:
  \[
  \begin{array}{lll}
    t ::= [[b]] \mid [[t1 + t2]] \mid [[t1 (+) t2]] \mid [[t1;t2]] \mid [[t1 (x) t2]]\\
  \end{array}
  \]
  I denote unsynchronized non-communicating parallel composition of
  attacks by $[[t1 + t2]]$, choice between attacks by $[[t1 (+) t2]]$,
  sequential composition of attacks by $[[t1;t2]]$, and a new
  operator called unsynchronized interacting parallel composition
  denoted $[[t1 (x) t2]]$.

  \ \\
  \noindent
  The following rules define the attack tree equivalence relation:
  \begin{center}
    \vspace{-14px}
    \footnotesize
    \begin{math}
      \begin{array}{c}
        \begin{array}{c}
        \inferrule* [right={\scriptsize assoc}] {
          \,
        }{[[(t1 op t2) op t3]] = [[t1 op (t2 op t3)]]}
      \end{array}
      \\
      \begin{array}{cccccccccccc}               
        \inferrule* [right={\scriptsize sym}] {
          \,
        }{[[t1 opS t2]] = [[t2 opS t1]]}
      \end{array}
      \\
      \inferrule* [right={\scriptsize $\textsc{dist}_1$}] {
          \,
        }{[[(t1 (+)  t2) + t3]] = [[(t1 + t3) (+) (t2 + t3)]]}
        \\
        \inferrule* [right={\scriptsize $\textsc{dist}_2$}] {
          \,
        }{[[(t1 (+)  t2) ; t3]] = [[(t1 ; t3) (+) (t2 ; t3)]]}
      \end{array}
    \end{math}    
  \end{center}
  where $\mathsf{op} \in \{\odot, \otimes, \rhd, \sqcup\}$ and $\mathsf{op_S}
  \in \{\odot, \otimes, \sqcup\}$.  
\end{definition}
The syntax given in the previous definition differs from the syntax
used by Jhawar et al. \cite{Jhawar:2015}.  First, I use infix binary
operations, while they use prefix $n$-ary operations. However, it does
not sacrifice any expressivity, because each operation is associative,
and parallel composition, choice, and interacting parallel composition
are symmetric.  Thus, Jhawar et al.'s definition of attack trees can
be embedded into the ones defined here.%% The hard
%% part of this embedding is realizing that the $n$-ary version of
%% sequential composition can be modeled by the binary version, but if we
%% have $\mathsf{SAND}(t_1,t_2,\ldots,t_n)$, then it is understood that
%% $t_1$ is executed, then $t_2$, and so on until $t_n$ is executed, but
%% this is exactly the same as $t_1;t_2;\cdots;t_n$.  

The second major difference is that the typical parallel composition
operator found in attack trees is modeled here by unsynchronized
non-communicating parallel composition which happens to be a symmetric
tensor product, and not a disjunction.  This is contrary to the
literature, for example, the parallel operation of Jhawar et
al. defined on source sink graphs \cite{Jhawar:2015} can be proven to
be a coproduct -- see
Appendix~\ref{sec:source_sink_graphs_are_symmetric_monoidal} -- and
coproducts categorically model disjunctions.  Furthermore, parallel
composition is modeled by multiset union in the multiset semantics,
but we can model this as a coproduct.  However, in the semantics given
in the next section if we took parallel composition to be a coproduct,
then the required isomorphisms necessary to model attack trees would
not exist.

The third difference is that I denote the choice between executing
attack $[[t1]]$ or attack $[[t2]]$, but not both, by $[[t1 (+) t2]]$
instead of using a symbol that implies that it is a disjunction.  This
fits very nicely with the semantics of Jhawar et al., where they
collect the attacks that can be executed into a set.  The semantics I
give in the next section models choice directly.

The fourth, and final, difference is that I extend the syntax with a
new operator called unsynchronized communicating parallel composition.
The attack $[[t1 (x) t2]]$ states that $[[t1]]$ interacts with the
attack $[[t2]]$ in the sense that processes interact.  Modeling
interacting attacks allows for the more refined modeling of security
critical systems, for example, it can be used to bring social
engineering into the analysis where someone communicates malicious
information or commands to a unsuspecting party.  As a second example,
interacting parallel composition could be used to model interacting
bot nets.

Finally, the equivalence relation is essentially the equivalence given
in Jhaware et al. \cite{Jhawar:2015} -- Theorem 1.
% section attack_trees (end)

\section{Semantics of Attack Trees in Dialectica Spaces}
\label{sec:concrete_semantics_of_attack_trees_in_dialectica_spaces}

I now introduce a new semantics of attack trees that connects their
study with a new perspective of attack trees that could highly impact
future research: intuitionistic linear logic, but it also strengthens
their connection to process calculi.  This section has been formalized
in the proof assistant Agda\footnote{The complete formalization can be
  found at
  \url{https://github.com/heades/dialectica-spaces/tree/PLAS16}
  which is part of a general library for working with dialectica
  spaces in Agda developed with Valeria de Paiva.}.  The semantics is
based on the notion of a dialectica space:

\begin{definition}
  \label{def:dialectica-space}
  A \textbf{dialectica space} is a triple $(A, Q, \delta)$ where $A$
  and $Q$ are sets and $\delta : A \times Q \to \mathsf{3}$ is a
  multi-relation where $\mathsf{3} = \{0,\perp,1\}$ and $\perp$
  represents undefined.
\end{definition}

Dialectica spaces can be seen as the intuitionistic cousin
\cite{dePaiva:2006b} of Chu spaces \cite{Pratt:1999}.  The latter have
be used extensively to study process algebra and as a model of
classical linear logic, while dialectica spaces and their morphisms
form a categorical model of intuitionistic linear logic called $\dial$
(originally due to \cite{dePaiva:1987}); I do not introduce
dialectica space morphisms here, but the curious reader can find the
definition in the formal development. I will use the intuitions often
used when explaining Chu spaces as processes to explain dialectica
spaces as processes, but it should be known that these intuitions are
due to Pratt and Gupta \cite{Gupta:1994}.

Intuitively, a dialectica space, $(A , Q, \delta)$, can be thought of
as a process where $A$ is the set of actions the process will execute,
$Q$ is the set of states the process can enter, and for $a \in A$ and
$q \in Q$, $\delta(a , q)$ indicates whether action $a$ can be
executed in state $q$.

The interpretation of attack trees into dialectica spaces requires the
construction of each operation on dialectica spaces:
{\vspace{-8pt}\ \\
\begin{changemargin}{2pt}{2pt}\noindent
\textbf{Parallel Composition.} Suppose $\cat{A} = (A , Q, \alpha)$ and
$\cat{B} = (B , R , \beta)$ are two dialectica spaces.  Then we can
construct -- due to de Paiva \cite{dePaiva:2014a} -- the dialectica
space $\cat{A} \odot \cat{B} = (A \times B, Q \times R, \alpha \odot
\beta)$ where $(\alpha \odot \beta)((a,b) , (q,r)) = \alpha(a , q)
\otimes_3 \beta(b , r)$ and $\otimes_3$ is the symmetric tensor
product definable on $\mathsf{3}$\footnote{See the formal development
  for the full definition:
  \url{https://github.com/heades/dialectica-spaces/blob/PLAS16/concrete-lineales.agda\#L328}}.
Thus, from a process perspective we can see that $\cat{A} \odot
\cat{B}$ executes actions of $\cat{A}$ and actions of $\cat{B}$ in
parallel.  Parallel composition is associative and symmetric.
\end{changemargin}

\begin{changemargin}{2pt}{2pt}\noindent
\textbf{Choice.} Suppose $\cat{A} = (A , Q, \alpha)$ and $\cat{B} = (B
, R , \beta)$ are two dialectica spaces.  Then we can construct the
dialectica space $\cat{A} \sqcup \cat{B} = (A + B, Q + R, \alpha
\sqcup \beta)$ where $(\alpha \sqcup \beta)(i , j) = \alpha(i , j)$ if
$i \in A$ and $j \in Q$, $(\alpha + \beta)(i , j) = \beta(i , j)$ if
$i \in B$ and $j \in R$, otherwise $(\alpha + \beta)(i , j) = 0$.
Thus, from a process perspective we can see that $\cat{A} \sqcup
\cat{B}$ executes either an action of $\cat{A}$ or an action of
$\cat{B}$, but not both.  Choice is symmetric and associative, but it
is not a coproduct, because it is not possible to define the
corresponding injections.  Brown et. al. show that Petri nets can be
modeled in dialectica spaces \cite{Brown:1991}, but they use the
coproduct as choice.  The operator given here is actually the
definition given for Chu spaces \cite{Gupta:1994}. If we were to use
the coproduct, then we would not be able to prove that choice
distributes over parallel composition nor over sequential
composition. As far as I am aware, this is the first time this has
been pointed out.
\end{changemargin}

\begin{changemargin}{2pt}{2pt}\noindent
\textbf{Sequential Composition.} Suppose $\cat{A} = (A , Q, \alpha)$
and $\cat{B} = (B , R , \beta)$ be two dialectica spaces.  Then we can
construct -- due to de Paiva \cite{dePaiva:2014a} -- the dialectica
space $\cat{A} \rhd \cat{B} = (A \times B, Q \times R, \alpha \rhd
\beta)$ where $(\alpha \rhd \beta)((a,b) , (q , r)) = \alpha(a , q)
\mathop{\mathsf{land}} \beta(i , r)$, and $\mathop{\mathsf{land}}$ is
lazy conjunction defined for $\mathsf{3}$\footnote{See the formal
  development for the full definition:
  \url{https://github.com/heades/dialectica-spaces/blob/PLAS16/concrete-lineales.agda\#L648}}.
This is a non-symmetric conjunctive operator, and thus, sequential
composition is non-symmetric.  This implies that from a process
perspective $\cat{A} \rhd \cat{B}$ will first execute the actions of
$\cat{A}$ and then execute actions of $\cat{B}$ in that order.
Sequential composition is associative.
\end{changemargin}

\begin{changemargin}{2pt}{2pt}\noindent
\textbf{Interacting Parallel Composition.} Suppose $\cat{A} = (A , Q,
\alpha)$ and $\cat{B} = (B , R , \beta)$ are two dialectica spaces.
Then we can construct the dialectica space $\cat{A} \otimes \cat{B} =
(A \times B, (B \rightarrow Q) \times (A \rightarrow R), \alpha
\otimes \beta)$ where $B \to Q$ and $A \to R$ denote function spaces,
and $(\alpha \otimes \beta)((a, b) , (f, g)) = \alpha(a , f(b)) \land
\beta(b,g(a))$.  From a process perspective the actions of $\cat{A}
\otimes \cat{B}$ are actions from $\cat{A}$ and actions of $\cat{B}$,
but the states are pairs of maps $f : B \to Q$ and $g : A \to R$ from
actions to states.  This is the point of interaction between the
processes.  This operator is symmetric and associative.
\end{changemargin}
} At this point it is straightforward to define an interpretation
$\interp{[[t]]}$ of attack trees into $\dial$.  Soundness with respect
to this model would correspond to the following theorem.

\begin{theorem}[Soundness]
  \label{thm:soundness}
  If $[[t1]] \rightsquigarrow [[t2]]$, then $\interp{[[t1]]}$ is
  isomorphic to $\interp{[[t2]]}$ in $\dial$.
\end{theorem}

Those familiar with Chu spaces and their application to process
algebra may be wondering how treating dialectica spaces as processes
differs.  The starkest difference is that in this model process
simulation is modeled by morphisms of the model, but this is not
possible in Chu spaces.  In fact, to obtain the expected properties of
processes a separate notion of bi-simulation had to be developed for
Chu spaces \cite{Gupta:1994}.  However, I took great care to insure
that the morphisms of our semantics capture the desired properties of
process simulation, and hence, attack trees.

The ability to treat morphisms as process simulation was not easy to
achieve.  The definition of choice in the semantics presented here
actually is the definition given for Chu spaces \cite{Gupta:1994}, but
Brown et al. use the coproduct defined for dialectica spaces to model
choice in Petri nets.  However, taking the coproduct for choice here
does not lead to the isomorphisms $(\cat{A} \sqcup \cat{B}) \rhd
\cat{C} \cong (\cat{A} \rhd \cat{C}) \sqcup (\cat{B} \rhd \cat{C})$
and $(\cat{A} \sqcup \cat{B}) \odot \cat{C} \cong (\cat{A} \odot
\cat{C}) \sqcup (\cat{B} \odot \cat{C})$, thus, we will not be able to
soundly model attack trees.  I have found that if choice is modeled
using the definition from Chu spaces \cite{Gupta:1994} then we obtain
these isomorphisms which is a novel result\footnote{For the proofs see
  the formal development:
  \url{https://github.com/heades/dialectica-spaces/blob/PLAS16/concurrency.agda\#L70}
  and
  \url{https://github.com/heades/dialectica-spaces/blob/PLAS16/concurrency.agda\#L150}}.

This semantics can be seen as a generalization of some existing
models.  Multisets, pomsets, and Petri nets can all be modeled by
dialectica spaces \cite{Brown:1991,Gupta:1994}.  However, there is a
direct connection between dialectica spaces and linear logic which
may lead to a logical theory of attack trees.
% section concrete_semantics_of_attack_trees_in_dialectica_spaces (end)

\section{Lina: A Domain Specific PL for Threat Analysis}
\label{sec:lina:_a_domain_specific_pl_for_threat_analysis}

The second major part of this project is the development of a
staticly-typed domain-specific linear functional programming language
for specifying and reasoning about attack trees called Lina for Linear
Threat Analysis.  Lina will consist of a core language and a surface
language.  We view attack trees as consisting of two layers: a logic
layer and a quantitative layer.  The former is described by the
definition of attack trees in the previous section, but the latter is
the layer added atop of the logical layer used when conducting
analysis, for example, computing set of attacks with minimal cost.
Thus, there are two types of proofs about attack trees.  Proofs about
the logical layer will be checked using a linear type system, but
proofs about the quantitative layer will be mostly numerical. In this
section we largely concentrate on the logical layer which is the
current focus of the project.

Lina's core will consist of a language for defining attack trees, and
this language will consist of the two layers, but one benefit of the
layered view of attack trees is that the logical layer can be
projected out, and hence, type checking may completely ignore the
quantitative layer.  The following two sections describe both of these
concepts.

\subsection{Lina's Core: Defining Attack Trees}
\label{subsec:linas_core_defining_attack_trees}

\input{def-lang-output}

% subsection linas_core_defining_attack_trees (end)

\subsection{Lina's Core: A Linear Type System}
\label{subsec:linas_core_linear_type_system}

The current main focus of the project is the design and analysis of
Lina's core type system.  However, there is a significant hurdle we
must get through first.  Types in Lina will correspond to attack trees
while programs correspond to semantically valid transformations of
attack trees, thus, a question we must answer then is \textbf{how do
  we sufficiently represent the model of attack trees in $\dial$ as a
  linear logic?}  The problem is the fact that Lina will require both
commutative (parallel composition and choice) and non-communicative
monoidal operators (sequencing).

Supporting both commutative and non-communicative operators within the
same linear logic has been a long standing question.  A starting point
might be with Reedy's LLMS which has already been shown to have a
categorical model in $\dial$ by de Paiva \cite{dePaiva:2014a}.  In
fact, the definition of non-interacting parallel composition given
here is due to her model.  However, we have taken a new path which we
also approach categorically, and then syntactically.

We have obtained a great insight from our model in dialectica
categories, but it is not obvious how to abstract it into a model we
can easily extract a type system from.  So instead of working directly
with the dialectica model we have found a more abstract model with the
ability to have both a commutative tensor product and and
non-communicative tensor product within the same model, but is more
straightforwardly transformed into a type system.

Girard's genius behind linear logic was that he isolated the
structural rules -- weakening and contraction -- by treating them as
an effect and putting them inside a comonad called the of-course
exponential denoted $!A$.  In fact, $!A \otimes !A$ is logically
equivalent to $!A$, and thus, by staying in the comonad we become
non-linear.  However, in Girard's linear logic exchange was not
isolated like weakening and contraction.  Thus, the tensor product was
symmetric.

To accommodate both a commutative and non-commutative tensor product
we isolate exchange in the same way that Girard isolated weakening and
contraction.  In this section I give a brief overview of how this is
done.  We begin with the notion of a Lambek category.
\begin{definition}
  \label{def:Lambek-category}
  A \textbf{Lambek category} is a monoidal category \\ $(\cat{C}, I,
  \rhd, \alpha, \lambda, \rho)$ where $\rhd : \cat{C} \times \cat{C}
  \mto \cat{C}$ is the non-commutative tensor product, and
  $\alpha_{A,B,C} : (A \rhd B) \rhd C \mto A \rhd (B \rhd C)$,
  $\lambda_A : I \rhd A \mto A$, and $\rho_A : A \rhd I \mto A$ are
  all natural transformations subject to several coherence
  diagrams\footnote{The coherence diagrams are equivalent to the ones
    in the definition of a symmetric monoidal category modulo
    symmetry; see the appendix for the complete definition of a
    symmetry monoidal category.}.
\end{definition}
\noindent
We call the previous category a Lambek category to pay homage to
Joachim Lambek and his work on the Lambeck calculus \cite{Lambek}
which is a non-commutative substructural logic that predates linear
logic.  The traditional definition of a Lambek category also requires
that the monoidal category be biclosed, but we do not concern
ourselves here with closed categories.

In our model exchange will be considered as an effect, and so we
isolate it inside a comonad.  This will allow for the definition of a
commutative tensor product.
\begin{definition}
  \label{def:exchange-comonad}
  A \textbf{Lambek category with exchange} is a Lambek category
  $(\cat{C}, I, \rhd, \alpha, \lambda, \rho)$ equipped with a monoidal
  comonad $(e, \varepsilon, \delta)$ where $e : \cat{C} \mto \cat{C}$
  is a monoidal endofunctor\footnote{For the full definition of a
    monoidal functor see Definition~\ref{?} in Appendix~\ref{?}.}, and
  $\varepsilon_A : eA \mto A$ and $\delta_A : eA \mto e^2A$ are
  natural transformations.  In addition, there is a natural
  transformation $\mathsf{ex}_{A,B} : e(A \rhd B) \mto eB \rhd
  eA$. Each of these morphisms are subject to the several coherence
  diagrams which we omit due to space.  Most importantly, the
  following diagram must commute:
  \[
  \bfig
    \square/->`=`->`/<1600,400>[
      e(A\otimes B)`
      eB\otimes eA`
      e(A\otimes B)`
      e(B\otimes A);
      \mathsf{ex}_{A,B}``
      q_{B,A}`]
    \morphism(800,0)<-800,0>[
      eA\otimes eB`
      e(A\otimes B);
      q_{A,B}]
    \morphism(1600,0)<-800,0>[
      e(B\otimes A)`
      eA\otimes eB;
      \mathsf{ex}_{B,A}]
    \efig
    \]
  
  
  %% \begin{mathpar}
  %%   \bfig
  %%   \square<600,600>[
  %%     eA`
  %%     e^2A`
  %%     e^2A`
  %%     e^3A;
  %%     \delta_A`
  %%     \delta_A`
  %%     e\delta_A`
  %%     \delta_{eA}]
  %%   \efig
  %%   \and
  %%   \bfig
  %%   \Atrianglepair/=`->`=`<-`->/<600,600>[
  %%     eA`
  %%     eA`
  %%     e^2 A`
  %%     eA;`
  %%     \delta_A``
  %%     \varepsilon_{eA}`
  %%     e\varepsilon_A]
  %%   \efig
  %%   \and
  %%   \bfig
  %%   \square|amab|/`->``->/<950,600>[
  %%     eA \rhd eB``
  %%     e^2A \rhd e^2B`
  %%     e(eA \rhd eB);`
  %%     \delta_A \rhd \delta_B``
  %%     q_{eA,eB}]
  %%   \square(950,0)|mmmb|/``->`->/<950,600>[`
  %%     e(A \rhd B)`
  %%     e(eA \rhd eB)`
  %%     e^2(A \rhd B);``
  %%     \delta_{A \rhd B}`
  %%     eq_{A,B}]
  %%   \morphism(0,600)<1900,0>[eA \rhd eB`e(A \rhd B);q_{A,B}]
  %%   \efig
  %%   \and
  %%   \bfig
  %%   \square<600,600>[
  %%     I`
  %%     eI`
  %%     eI`
  %%     e^2I;
  %%     q_{I}`
  %%     q_{I}`
  %%     \delta_I`
  %%     eq_{I}]
  %%   \efig
    %% \end{mathpar}
    \noindent
  The previous diagram can be seen as a form of invertibility for
  $\mathsf{ex}_{A,B}$.
\end{definition}
The previous definition is largely based on how weakening and
contraction are modeled by the of-course exponential, and how exchange
operates in the coKleisli category of $(e, \varepsilon, \delta)$.  The
coKleisli category contains as objects all of the objects of
$\cat{C}$, but has as morphisms all the morphisms of $\cat{C}$ whose
source is of the form $eA$ for some $A$.  The coKleisli category is
best viewed as the world inside a comonad.  That is, it contains all
of the structure of the ambient category, but also the additional
effects the comonad provides.  Thus, the coKleisli category of the
exchange comonad should be a symmetric monoidal category, and indeed
it is.
\begin{lemma}
  \label{lemma:cokleisli_of_the_exchange_monad_is_symmetric}
  Suppose $\cat{C}$ is a Lambek category with exchange.  Then the
  coKleisli category of the exchange comonad is symmetric monoidal.
\end{lemma}
It is now should be more straightforward to construct a term
assignment from this model.  The following rules define a preliminary
definition of a natural deduction term assignment:
\begin{mathpar}
  \small
  \ATreesdrulevar{}    \and
  \ATreesdruleunitI{}  \and
  \ATreesdruleunitE{}  \and
  \ATreesdruletenI{}   \and
  \ATreesdruletenE{}   \and
  \ATreesdruleex{}   \and
  \ATreesdruledereliction{}  \and
  \ATreesdrulepromotion{}  
\end{mathpar}
The previous rules are based on the natural deduction formalization of
intuitionistic linear logic due to \cite{Benton:1992}.

We can interpret both sequential and interacting parallel composition
as types.  That is, we can interpret $[[t1 ; t2]]$ as $[[T1 (x) T2]]$,
and $[[t1 (x) t2]]$ as $[[e T1 (x) e T2]]$.  However, accommodating
the other attack tree branching connectives in linear logic is left
for future work.
% subsection linas_core_linear_type_system (end)

\subsection{Lina's Surface Language}
\label{subsec:linas_surface_language}
Another goal of this project is to make using Lina as close as
possible to functional programming as usual to prevent a large
overhead of using the language as well as the tool.  As a programming
language simplicity is of the utmost importance, and I think with the
semantics given here Lina will not require very advanced syntactic
features.  This cannot be said for some of the existing work that is
similar to Lina.  For example, Vigo et al. \cite{6957121} proposed the
Quality Tree Generator which requires the user to program in a process
calculus which is a non-trivial overhead. At the tool level the goal
is to have a completely graphical environment for creating attack
trees and reasoning about them by capitalizing on existing graphical
reasoning tools from category theory.  Thus, at the tool level the
user will not have to write any programs at all unless they want to
extend the environment.
% subsection linas_surface_language (end)

\subsection{Automation}
\label{subsec:automation}
I do not consider this project, particularly Lina, to be at odds with
existing work on using automated theorem proving to synthesize and
analyze attack trees; see for example
\cite{essay69399,Sheyner:2002:AGA:829514.830526,6957121,essay69402}.
In fact, this project can benefit from automated generation of attack
trees.  Lina's primary goal is to make reasoning about attack trees
safer by having a tight correspondence with the semantics of attack
trees, and thus, will allow and help with the creation of attack
trees.  Lina will offer a manual way for one to create an attack tree,
but by leveraging this existing work could allow for their automatic
generation, but then could be used to restructure the tree and conduct
further analysis in a semantically valid fashion.  In addition, Lina
can be seen as an interactive theorem prover for attack trees, and so
could be used as a proof checker \cite{Stump:2012} for proof producing
SMT backed automated generation of attack trees, thus, potentially
allowing for some of the analysis of attack trees in Lina to be
automated.
% subsection automation (end)
% section lina:_a_domain_specific_pl_for_threat_analysis (end)

\section{Conclusion and Future Work}
\label{sec:conclusion}

The project described here is to first develop the semantics of attack
trees (Section~\ref{sec:attack_trees}) in dialectica spaces
(Section~\ref{sec:concrete_semantics_of_attack_trees_in_dialectica_spaces}),
a model of full intuitionistic linear logic, and then exploiting the
Curry-Howard-Lambek correspondence to develop a new functional
programming language called Lina
(Section~\ref{sec:lina:_a_domain_specific_pl_for_threat_analysis}) to
be used to develop a new tool to conduct threat analysis using attack
trees.  This tool will include the ability to design and formally
reason about attack trees using interactive theorem proving.

The core language will include a decidable type checker
using term annotations on types.  Programming with annotations can be
very cumbersome, and so the surface language will use local type
inference \cite{Pierce:2000} to alleviate some of the burden from
annotations.  
% section conclusion_and_future_work (end)


%% \bibliographystyle{plain} \bibliography{ref}

\begin{thebibliography}{10}
  \softraggedright
  
\bibitem[Barr(1991)Barr]{MSC:4439568}
  Michael Barr.
  \newblock *-autonomous categories and linear logic.
  \newblock {\em Mathematical Structures in Computer Science}, 1:159--178, 7
  1991.

\bibitem[Brown(1991)Brown,Gurr,de Paiva]{Brown:1991}
  Carolyn Brown, Doug Gurr, and Valeria de Paiva.
  \newblock A linear specification language for petri nets.
  \newblock {\em DAIMI Report Series}, 20(363), 1991.

\bibitem[de Paiva(1989)de Paiva]{dePaiva:1987}
  Valeria de~Paiva.
  \newblock Dialectica categories.
  \newblock In J.~Gray and A.~Scedrov, editors, {\em Categories in Computer
    Science and Logic}, volume~92, pages 47--62. Amerian Mathemaitcal Society,
  1989.

\bibitem[de Paiva(2006)de Paiva]{dePaiva:2006b}
  Valeria de~Paiva.
  \newblock Dialectica and chu constructions: Cousins?
  \newblock {\em Theory and Applications of Categories}, 17(7):127--152, 2006.

\bibitem[de Paiva(2014)de Paiva]{dePaiva:2014a}
  Valeria de~Paiva.
  \newblock Linear logic model of state revisited.
  \newblock {\em Logic Journal of IGPL}, 22(5):791--804, 2014.

\bibitem[Fiore(2013)Fiore,Devesas~Campos]{Fiore:2013}
  Marcelo Fiore and Marco Devesas~Campos.
  \newblock {\em Computation, Logic, Games, and Quantum Foundations. The Many
    Facets of Samson Abramsky: Essays Dedicated to Samson Abramsky on the
    Occasion of His 60th Birthday}, chapter The Algebra of Directed Acyclic
  Graphs, pages 37--51.
  \newblock Springer Berlin Heidelberg, Berlin, Heidelberg, 2013.

\bibitem[Francesco~Albasini(2010)Francesco~Albasini,Sabadini,Walters]{FrancescoAlbasini2010}
  Luisa Francesco~Albasini, Nicoletta Sabadini, and Robert F.~C. Walters.
  \newblock The compositional construction of markov processes.
  \newblock {\em Applied Categorical Structures}, 19(1):425--437, 2010.

\bibitem[Girad(1987)Girard]{Girard:1987}
  Jean-Yves Girard.
  \newblock Linear logic.
  \newblock {\em Theoretical Computer Science}, 50(1):1 -- 101, 1987.

\bibitem[Gupta(1994)Gupta]{Gupta:1994}
  Vineet Gupta.
  \newblock {\em Chu Spaces: a Model of Concurrency}.
  \newblock PhD thesis, Stanford University, 1994.

\bibitem[Huistra(2016)Huistra]{essay69399}
  D.J. {Huistra}.
  \newblock Automated generation of attack trees by unfolding graph
  transformation systems, March 2016.

\bibitem[Jhawar(2015)Jhawar,Kordy,Mauw,Radomirovi{\"A}]{Jhawar:2015}
  Ravi Jhawar, Barbara Kordy, Sjouke Mauw, Sa{\AA}{!'}a Radomirovi{\"A}, and
  Rolando Trujillo-Rasua.
  \newblock Attack trees with sequential conjunction.
  \newblock In Hannes Federrath and Dieter Gollmann, editors, {\em ICT Systems
    Security and Privacy Protection}, volume 455 of {\em IFIP Advances in
    Information and Communication Technology}, pages 339--353. Springer
  International Publishing, 2015.

\bibitem[Kordy(2014)Kordy,Pi{\'e}tre-Cambac{\'e}d{\'e}s,Schweitzer]{Kordy:2014a}
  Barbara Kordy, Ludovic Pi{\'e}tre-Cambac{\'e}d{\'e}s, and Patrick Schweitzer.
  \newblock Dag-based attack and defense modeling: Don't miss the forest for the
  attack trees.
  \newblock {\em Computer Science Review}, 13{\^a}14:1 -- 38, 2014.

\bibitem[Mauw(2006)Mauw,Oostdijk]{Mauw:2006}
  Sjouke Mauw and Martijn Oostdijk.
  \newblock Foundations of attack trees.
  \newblock In DongHo Won and Seungjoo Kim, editors, {\em Information Security
    and Cryptology - ICISC 2005}, volume 3935 of {\em Lecture Notes in Computer
    Science}, pages 186--198. Springer Berlin Heidelberg, 2006.

\bibitem[Pierce(2000)Pierce,Turner]{Pierce:2000}
  Benjamin~C. Pierce and David~N. Turner.
  \newblock Local type inference.
  \newblock {\em ACM Trans. Program. Lang. Syst.}, 22(1):1--44, January 2000.

\bibitem[Pratt(1999)Pratt]{Pratt:1999}
  Vaughan Pratt.
  \newblock Chu spaces.
  \newblock Notes for the School on Category Theory and Applications University
  of Cimbra, July 1999.

\bibitem[Retore(1997)Retore]{Retore:1997}
  Christian Retor{\'e}.
  \newblock {\em Typed Lambda Calculi and Applications: Third International
    Conference on Typed Lambda Calculi and Applications TLCA '97 Nancy, France,
    April 2--4, 1997 Proceedings}, chapter Pomset logic: A non-commutative
  extension of classical linear logic, pages 300--318.
  \newblock Springer Berlin Heidelberg, Berlin, Heidelberg, 1997.

\bibitem[Selinger(2009)Selinger]{Selinger:2009}
  Peter {Selinger}.
  \newblock {A survey of graphical languages for monoidal categories}.
  \newblock {\em ArXiv e-prints}, August 2009.

\bibitem[Sheyner(2002)Sheyner,Haines,Jha,Lippmann,Wing]{Sheyner:2002:AGA:829514.830526}
  Oleg Sheyner, Joshua Haines, Somesh Jha, Richard Lippmann, and Jeannette~M.
  Wing.
  \newblock Automated generation and analysis of attack graphs.
  \newblock In {\em Proceedings of the 2002 IEEE Symposium on Security and
    Privacy}, SP '02, pages 273--, Washington, DC, USA, 2002. IEEE Computer
  Society.

\bibitem[Stump(2012)Stump,Reynolds,Tinelli,Laugesen,Eades,Oliver,Zhang]{Stump:2012}
  Aaron Stump, Andrew Reynolds, Cesare Tinelli, Austin Laugesen, Harley D.~Eades
  III, Corey Oliver, and Ruoyu Zhang.
  \newblock Lfsc for smt proofs: Work in progress.
  \newblock In {\em Proceedings of the Second International Workshop on Proof
    Exchange for Theorem Proving (PXTP 2012)}, 2012.

\bibitem[Tzouvaras(1998)Tzouvaras]{Tzouvaras:1998}
  A~Tzouvaras.
  \newblock The linear logic of multisets.
  \newblock {\em Logic Journal of IGPL}, 6(6):901--916, 1998.

\bibitem[Vigo(2014)Vigo,Nielson,Nielson]{6957121}
  R.~Vigo, F.~Nielson, and H.~R. Nielson.
  \newblock Automated generation of attack trees.
  \newblock In {\em Computer Security Foundations Symposium (CSF), 2014 IEEE
    27th}, pages 337--350, July 2014.

\bibitem[Wolters(2016)Wolters]{essay69402}
  N.H. {Wolters}.
  \newblock Analysis of attack trees with timed automata (transforming formalisms
  through metamodeling), March 2016.

\end{thebibliography}


\appendix

\section*{Appendix}
\label{sec:appendix}
\section{Symmetric Monoidal Categories}
\label{sec:symmetric_monoidal_categories}
\input{appendix-SMC}
% section symmetric_monoidal_categories (end)

\section{Source Sink Graphs are Symmetric Monoidal}
\label{sec:source_sink_graphs_are_symmetric_monoidal}
\input{appendix-SSG-monoidal}
% section source_sink_graphs_are_symmetric_monoidal (end)
% section appendix (end)



\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

