\documentclass{llncs}

\usepackage{amssymb,amsmath}
\usepackage{cmll}
\usepackage{stmaryrd}
\usepackage{todonotes}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[barr]{xy}

%% This renames Barr's \to to \mto.  This allows us to use \to for imp
%% and \mto for a inline morphism.
\let\mto\to
\let\to\relax
\newcommand{\to}{\rightarrow}

% Commands that are useful for writing about type theory and programming language design.
%% \newcommand{\case}[4]{\text{case}\ #1\ \text{of}\ #2\text{.}#3\text{,}#2\text{.}#4}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\normto}[0]{\rightsquigarrow^{!}}
\newcommand{\join}[0]{\downarrow}
\newcommand{\redto}[0]{\rightsquigarrow}
\newcommand{\nat}[0]{\mathbb{N}}
\newcommand{\fun}[2]{\lambda #1.#2}
\newcommand{\CRI}[0]{\text{CR-Norm}}
\newcommand{\CRII}[0]{\text{CR-Pres}}
\newcommand{\CRIII}[0]{\text{CR-Prog}}
\newcommand{\subexp}[0]{\sqsubseteq}
%% Must include \usepackage{mathrsfs} for this to work.
\newcommand{\powerset}[0]{\mathscr{P}}

\date{}

% Cat commands.
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\catop}[1]{\cat{#1}^{\mathsf{op}}}
\newcommand{\Hom}[3]{\mathsf{Hom}_{\cat{#1}}(#2,#3)}
\newcommand{\limp}[0]{\multimap}
\newcommand{\dial}[0]{\mathsf{Dial_3}(\mathsf{Sets})}
\newcommand{\dialSets}[1]{\mathsf{Dial_{#1}}(\mathsf{Sets})}
\newcommand{\dcSets}[1]{\mathsf{DC_{#1}}(\mathsf{Sets})}
\newcommand{\sets}[0]{\mathsf{Sets}}
\newcommand{\obj}[1]{\mathsf{Obj}(#1)}
\newcommand{\mor}[1]{\mathsf{Mor(#1)}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\lett}[0]{\mathsf{let}\,}
\newcommand{\inn}[0]{\,\mathsf{in}\,}
\newcommand{\cur}[1]{\mathsf{cur}(#1)}
\newcommand{\curi}[1]{\mathsf{cur}^{-1}(#1)}

\newenvironment{changemargin}[2]{%
  \begin{list}{}{%
    \setlength{\topsep}{0pt}%
    \setlength{\leftmargin}{#1}%
    \setlength{\rightmargin}{#2}%
    \setlength{\listparindent}{\parindent}%
    \setlength{\itemindent}{\parindent}%
    \setlength{\parsep}{\parskip}%
  }%
  \item[]}{\end{list}}

%% % Theorems
%% \newtheorem{theorem}{Theorem}
%% \newtheorem{lemma}[theorem]{Lemma}
%% \newtheorem{fact}[theorem]{Fact}
%% \newtheorem{corollary}[theorem]{Corollary}
%% \newtheorem{definition}[theorem]{Definition}
%% \newtheorem{remark}[theorem]{Remark}
%% \newtheorem{proposition}[theorem]{Proposition}
%% \newtheorem{notn}[theorem]{Notation}
%% \newtheorem{observation}[theorem]{Observation}

%% Ott
\input{atrees-ott}
\input{type-level-Lina-ott}

\begin{document}

%% \conferenceinfo{PLAS '16}{October 24, 2016, Vienna, Austria}
%% \copyrightyear{2016}
%% \copyrightdata{}
%% \copyrightdoi{}
%% \titlebanner{}

\title{Project Update: A New Foundation of Attack Trees in Linear Logic}

\author{Harley Eades III}
\institute{Computer Science\\Augusta University \\ \href{mailto:heades@augusta.edu}{harley.eades@gmail.com}}

\maketitle 

\begin{abstract}
  In this short paper I provide an update on the status of newly
  funded research project investigating founding attack trees in the
  resource conscious theory called linear logic.  
\end{abstract}

\section{Introduction}
\label{sec:introduction}
%% the problem?
What is a mathematical model of attack trees?  There have been
numerous proposed answers to this question.  Some examples are
propositional logic, multisets, directed acyclic graphs, source sink
graphs (or parallel-series pomsets), Petri nets, and Markov processes.
Is there a unifying foundation in common to each of these proposed
models?  Furthermore, can this unifying foundation be used to further
the field of attack trees and build new tools for conducting threat
analysis?

The answer to the first question is positive, but the answer to the
second question is open.  Each of the proposed models listed above
have something in common.  They can all be modeled in some form of a
symmetric monoidal category\footnote{I provide a proof that the
  category of source sink graphs is monoidal in
  Appendix~\ref{sec:source_sink_graphs_are_symmetric_monoidal}.}
\cite{Tzouvaras:1998,Brown:1991,Fiore:2013,FrancescoAlbasini2010} --
for the definition of a symmetric monoidal category see
Appendix~\ref{sec:symmetric_monoidal_categories}.  That is all well
and good, but what can we gain from monoidal categories?

Monoidal categories are a mathematical model of linear logic as
observed through the beautiful Curry-Howard-Lambek correspondence
\cite{Mellies:2009}.  In linear logic every hypothesis must be used
exactly once, and hence, if we view a hypothesis as a resource, then
this property can be stated as every resource must be consumed.  This
linearity property is achieved by removing the structural rules for
weakening and contraction from classical or intuitionistic logic.
Thus, from a resource perspective, resources cannot be spontaneously
created or duplicated -- hence, propositional logic can be viewed as a
degenerate, from a resource perspective, form of linear logic.

Multisets and Petri nets both capture the idea that the nodes of an
attack tree capture both the attack action and the state -- the
resource -- of the system being analyzed. As it turns out, linear
logic has been shown to be a logical foundation for multisets
\cite{Tzouvaras:1998} and Petri Nets \cite{Brown:1991}.  Thus, linear
logic has the ability to model the state as well as attack actions of
the goals of an attack tree.  We propose that linear logic be used as
the logical foundation of attack trees.

This projects\footnote{This material is based upon work supported by
  the National Science Foundation CRII CISE Research Initiation grant,
  ``CRII:SHF: A New Foundation for Attack Trees Based on Monoidal
  Categories``, under Grant No. 1565557.} main goal is to determine
the suitability of linear logic as a foundation for attack trees.  The
type of attack trees we consider in this paper are attack trees with
sequential composition similar to Jhawar et al.~\cite{Jhawar:2015}.
Attack trees consist of two layers: the logical layer or process tree,
and the quantitative layer.  One interesting aspect of our proposed
foundation is that the logical layer can come to the aid of the
quantitative layer.

At the logical layer the base attacks of an attack tree will
correspond to atomic formulas in linear logic, and each branching node
of an attack tree will correspond to a binary operator in linear
logic.  Adding costs corresponds to annotating the atomic formulas
with some base cost, and then annotating the binary operators with a
cost computed from the costs of their respective left operand (left
subtree) and right operand (right subtree).  The most interesting
aspect of adding costs is that computing the costs at the branching
nodes is done during the construction of a derivation using the
inference rules of the logic.

The inference rules of linear logic provide a number of benefits when
constructing attack trees.  First, the inference rules will certify
that an attack tree is constructed correctly and all costs on
branching nodes will be computed from the costs of the left and right
subtrees.  On top of that the inference rules offer a means of proving
when two attack trees are equivalent. Leveraging the fact that
language of attack trees corresponds to a very simple fragment of
linear logic, e.g. linear implication is not needed, I conjecture
that proving equivalence of attack trees can be automated.  Thus, this
could be used in practice to certify the correctness of
transformations of attack trees maintaining the resource based
semantics.

\section{Attack Trees}
\label{sec:attack_trees}
In this section I introduce attack trees with sequential composition
first proposed by Jhawar et al. \cite{Jhawar:2015}.  One of the
projects ultimate goals is to extend attack trees with even more
operators driven by our choice of semantics, but we leave this to
future work.  The syntax for attack trees is defined in the following
definition.
\begin{definition}
  \label{def:atrees}
  Suppose $\mathsf{B}$ is a set of base attack, $\mathsf{C}$ is
  a set of costs, $\Sigma =
  \{\mathsf{op}_{\odot}, \mathsf{op}_\rhd, \mathsf{op}_\sqcup \}$ is a set of binary
  operations on $\mathsf{C}$, and $I = \{i_\odot, i_\rhd, i_\sqcup\}$ is a set of
  identities, such that, each $l \in \{ \mathsf{op}_{\odot}, \mathsf{op}_\sqcup \}$, $\mathsf{op}_l \in \Sigma$ and $i_l \in
  I$ make $(\mathsf{C}, \mathsf{op}_l, i_l)$ a commutative monoid, and
  $(\mathsf{C}, \mathsf{op}_\rhd, i_\rhd)$ a non-communicative monoid.

  \ \\
  \noindent
  The following defines the syntax of \textbf{Attack Trees} given an
  assignment $\mathsf{c} : \mathsf{B} \to \mathsf{C}$ of base attacks
  to costs:
  \[
  \begin{array}{lll}
    t ::= [[(b, c(b))]] \mid [[t1 (+)op t2]] \mid [[t1 +op t2]] \mid [[t1 ;op  t2]]\\
  \end{array}
  \]
  I denote unsynchronized parallel composition of attacks by $[[t1 +op
      t2]]$, choice between attacks by $[[t1 (+)op t2]]$, and sequential
  composition of attacks by $[[t1 ;op t2]]$.

  \ \\
  \noindent
  The following rules define the attack tree equivalence relation
  (omitting operation annotations for readability):
  \begin{center}
    \vspace{-14px}
    \footnotesize
    \begin{math}
      \begin{array}{cccccccc}
        \begin{array}{c}
          \inferrule* [right={\scriptsize assoc}] {
            \,
          }{[[(t1 op t2) op t3]] = [[t1 op (t2 op t3)]]}
        \\
        \inferrule* [right={\scriptsize sym}] {
          \,
        }{[[t1 opS t2]] = [[t2 opS t1]]}
      \end{array}
        & \quad &
        \begin{array}{lll}
          \inferrule* [right={\scriptsize $\textsc{dist}_1$}] {
          \,
        }{[[(t1 (+)  t2) + t3]] = [[(t1 + t3) (+) (t2 + t3)]]}
        \\
        \inferrule* [right={\scriptsize $\textsc{dist}_2$}] {
          \,
        }{[[(t1 (+)  t2) ; t3]] = [[(t1 ; t3) (+) (t2 ; t3)]]}
        \end{array}
      \end{array}
    \end{math}    
  \end{center}
  where $\mathsf{op} \in \{\odot, \rhd, \sqcup\}$ and $\mathsf{op_S}
  \in \{\odot, \sqcup\}$.  
\end{definition}
The equivalence relation is essentially the equivalence given in
Jhaware et al. \cite{Jhawar:2015} -- Theorem 1.  Conducting an
analysis of the threat potential of a complex system might yield an
attack tree that must be rearranged to be understood, but this
rearrangement should not compromise the meaning of the tree.

We wish to treat attack trees as formulas of a linear logic where
$[[t1 (+)op t2]]$ is the commutative tensor product and $[[t1 ;op
    t2]]$ is the non-communicative tensor product.  Incorporating
these two operators within the same linear logic is an interesting
question in itself.
% section attack_trees (end)

\section{A Linear Logic for Attack Trees}
\label{sec:a_linear_logic_for_attack_trees}
\input{ll-attack-output}
% section a_linear_logic_for_attack_trees (end)


\bibliographystyle{plain}
\bibliography{ref}

\appendix

\section*{Appendix}
\label{sec:appendix}
\section{Symmetric Monoidal Categories}
\label{sec:symmetric_monoidal_categories}
\input{appendix-SMC}
% section symmetric_monoidal_categories (end)

\section{Source Sink Graphs are Symmetric Monoidal}
\label{sec:source_sink_graphs_are_symmetric_monoidal}
\input{appendix-SSG-monoidal}
% section source_sink_graphs_are_symmetric_monoidal (end)

\section{Typing for Lina's Quantitative Expressions}
\label{sec:lina's_attack_tree_definition_language}
\begin{mathpar}
  \TLLdruleQXXVar{} \and
  \TLLdruleQXXDouble{} \and
  \TLLdruleQXXFun{} \and
  \TLLdruleQXXApp{} \and
  \TLLdruleQXXNOp{} \and
  \TLLdruleQXXRec{}
\end{mathpar}
% section lina's_attack_tree_definition_language (end)


% section appendix (end)



\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

