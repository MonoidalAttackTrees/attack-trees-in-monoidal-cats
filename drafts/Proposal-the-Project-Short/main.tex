\documentclass{llncs}

\usepackage{amssymb,amsmath}
\usepackage{cmll}
\usepackage{stmaryrd}
\usepackage{todonotes}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[barr]{xy}
\usepackage{mdframed}

%% This renames Barr's \to to \mto.  This allows us to use \to for imp
%% and \mto for a inline morphism.
\let\mto\to
\let\to\relax
\newcommand{\to}{\rightarrow}

% Commands that are useful for writing about type theory and programming language design.
%% \newcommand{\case}[4]{\text{case}\ #1\ \text{of}\ #2\text{.}#3\text{,}#2\text{.}#4}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\normto}[0]{\rightsquigarrow^{!}}
\newcommand{\join}[0]{\downarrow}
\newcommand{\redto}[0]{\rightsquigarrow}
\newcommand{\nat}[0]{\mathbb{N}}
\newcommand{\fun}[2]{\lambda #1.#2}
\newcommand{\CRI}[0]{\text{CR-Norm}}
\newcommand{\CRII}[0]{\text{CR-Pres}}
\newcommand{\CRIII}[0]{\text{CR-Prog}}
\newcommand{\subexp}[0]{\sqsubseteq}
%% Must include \usepackage{mathrsfs} for this to work.
\newcommand{\powerset}[0]{\mathscr{P}}

\date{}

% Cat commands.
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\catop}[1]{\cat{#1}^{\mathsf{op}}}
\newcommand{\Hom}[3]{\mathsf{Hom}_{\cat{#1}}(#2,#3)}
\newcommand{\limp}[0]{\multimap}
\newcommand{\dial}[0]{\mathsf{Dial_3}(\mathsf{Sets})}
\newcommand{\dialSets}[1]{\mathsf{Dial_{#1}}(\mathsf{Sets})}
\newcommand{\dcSets}[1]{\mathsf{DC_{#1}}(\mathsf{Sets})}
\newcommand{\sets}[0]{\mathsf{Sets}}
\newcommand{\obj}[1]{\mathsf{Obj}(#1)}
\newcommand{\mor}[1]{\mathsf{Mor(#1)}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\lett}[0]{\mathsf{let}\,}
\newcommand{\inn}[0]{\,\mathsf{in}\,}
\newcommand{\cur}[1]{\mathsf{cur}(#1)}
\newcommand{\curi}[1]{\mathsf{cur}^{-1}(#1)}

\newenvironment{changemargin}[2]{%
  \begin{list}{}{%
    \setlength{\topsep}{0pt}%
    \setlength{\leftmargin}{#1}%
    \setlength{\rightmargin}{#2}%
    \setlength{\listparindent}{\parindent}%
    \setlength{\itemindent}{\parindent}%
    \setlength{\parsep}{\parskip}%
  }%
  \item[]}{\end{list}}

%% % Theorems
%% \newtheorem{theorem}{Theorem}
%% \newtheorem{lemma}[theorem]{Lemma}
%% \newtheorem{fact}[theorem]{Fact}
%% \newtheorem{corollary}[theorem]{Corollary}
%% \newtheorem{definition}[theorem]{Definition}
%% \newtheorem{remark}[theorem]{Remark}
%% \newtheorem{proposition}[theorem]{Proposition}
%% \newtheorem{notn}[theorem]{Notation}
%% \newtheorem{observation}[theorem]{Observation}

%% Ott
\input{atrees-ott}
\input{ll-attack-ott}
\input{oll-ott}
\renewcommand{\LLAdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\LLAdrulename{#4}}}
\renewcommand{\LLAdrulename}[1]{#1}
\renewcommand{\LLAdruleTXXvarName}{\text{id}_{\odot}}
\renewcommand{\LLAdruleTXXvarCName}{\text{id}_{\rhd}}
\renewcommand{\LLAdruleTXXparaName}{\odot}
\renewcommand{\LLAdruleTXXseqName}{\rhd}
\renewcommand{\LLAdruleTXXchoiceName}{\sqcup}

\renewcommand{\LLAdruleEXXvarName}{\text{id}_{\odot}}
\renewcommand{\LLAdruleEXXvarCName}{\text{id}_{\rhd}}
\renewcommand{\LLAdruleEXXchoiceContName}{\text{cont}_\sqcup}
\renewcommand{\LLAdruleEXXchoiceSymName}{\text{sym}_\sqcup}
\renewcommand{\LLAdruleEXXchoiceAssocName}{\text{assoc}_\sqcup}
\renewcommand{\LLAdruleEXXdistParaName}{\text{dis}_\odot}
\renewcommand{\LLAdruleEXXdistSeqName}{\text{dis}_\rhd}
\renewcommand{\LLAdruleEXXparaIName}{\odot_I}
\renewcommand{\LLAdruleEXXparaEName}{\odot_E}
\renewcommand{\LLAdruleEXXseqIName}{\rhd_I}
\renewcommand{\LLAdruleEXXseqEName}{\rhd_E}
\renewcommand{\LLAdruleEXXexName}{\text{sym}_\odot}
\renewcommand{\LLAdruleEXXchoiceName}{\sqcup}
\renewcommand{\LLAdruleEXXimpIName}{\multimap_I}
\renewcommand{\LLAdruleEXXimpEName}{\multimap_E}

\renewcommand{\ATLLdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\ATLLdrulename{#4}}}
\renewcommand{\ATLLdrulename}[1]{#1}
\renewcommand{\ATLLdruleTXXvarName}{\text{id}_{\odot}}
\renewcommand{\ATLLdruleTXXvarCName}{\text{id}_{\rhd}}
\renewcommand{\ATLLdruleTXXparaName}{\odot}
\renewcommand{\ATLLdruleTXXseqName}{\rhd}
\renewcommand{\ATLLdruleTXXchoiceName}{\sqcup}

\renewcommand{\ATLLdruleEXXvarName}{\text{id}_{\odot}}
\renewcommand{\ATLLdruleEXXvarCName}{\text{id}_{\rhd}}
\renewcommand{\ATLLdruleEXXchoiceContName}{\text{cont}_\sqcup}
\renewcommand{\ATLLdruleEXXchoiceSymName}{\text{sym}_\sqcup}
\renewcommand{\ATLLdruleEXXchoiceAssocName}{\text{assoc}_\sqcup}
\renewcommand{\ATLLdruleEXXdistParaName}{\text{dis}_\odot}
\renewcommand{\ATLLdruleEXXdistSeqName}{\text{dis}_\rhd}
\renewcommand{\ATLLdruleEXXparaIName}{\odot_I}
\renewcommand{\ATLLdruleEXXparaEName}{\odot_E}
\renewcommand{\ATLLdruleEXXseqIName}{\rhd_I}
\renewcommand{\ATLLdruleEXXseqEName}{\rhd_E}
\renewcommand{\ATLLdruleEXXexName}{\text{sym}_\odot}
\renewcommand{\ATLLdruleEXXchoiceName}{\sqcup}
\renewcommand{\ATLLdruleEXXimpIName}{\multimap_I}
\renewcommand{\ATLLdruleEXXimpEName}{\multimap_E}
\renewcommand{\ATLLdruleEXXweakSName}{\text{wk}_\odot}
\renewcommand{\ATLLdruleEXXweakPName}{\text{wk}_\rhd}

\begin{document}

%% \conferenceinfo{PLAS '16}{October 24, 2016, Vienna, Austria}
%% \copyrightyear{2016}
%% \copyrightdata{}
%% \copyrightdoi{}
%% \titlebanner{}

\title{Project Update: A New Foundation of Attack Trees in Linear Logic}

\author{Harley Eades III}
\institute{Computer Science\\Augusta University \\ \href{mailto:heades@augusta.edu}{harley.eades@gmail.com}}

\maketitle 

\begin{abstract}
  In this short paper I provide an update on the status of newly
  funded research project investigating founding attack trees in the
  resource conscious theory called linear logic.  I introduce a new
  linear logic called the Attack Tree Linear Logic (ATLL) which models
  attack trees as formulas and uses implication to reason about attack
  trees.  I then introduce a new generalization of Bucciarelli and
  Ehrhardâ€™s indexed linear logic to obtain Indexed ATLL which adds
  costs to attack trees.  The most interesting aspect of Indexed ATLL
  is that implication is endowed with a relation for taking into
  consideration the costs while reasoning about attack trees.x
\end{abstract}

\section{Introduction}
\label{sec:introduction}
%% the problem?
What is a mathematical model of attack trees?  There have been
numerous proposed answers to this question.  Some examples are
propositional logic, multisets, directed acyclic graphs, source sink
graphs (or parallel-series pomsets), Petri nets, and Markov processes.
Is there a unifying foundation in common to each of these proposed
models?  Furthermore, can this unifying foundation be used to further
the field of attack trees and build new tools for conducting threat
analysis?

The answer to the first question is positive, but the answer to the
second question is open.  Each of the proposed models listed above
have something in common.  They can all be modeled in some form of a
symmetric monoidal category
\cite{Tzouvaras:1998,Brown:1991,Fiore:2013,FrancescoAlbasini2010}.
That is all well and good, but what can we gain from monoidal
categories?

Monoidal categories are a mathematical model of linear logic as
observed through the beautiful Curry-Howard-Lambek correspondence
\cite{Mellies:2009}.  In linear logic every hypothesis must be used
exactly once, and hence, if we view a hypothesis as a resource, then
this property can be stated as every resource must be consumed.  This
linearity property is achieved by removing the structural rules for
weakening and contraction from classical or intuitionistic logic.
Thus, from a resource perspective, resources cannot be spontaneously
created or duplicated -- hence, propositional logic can be viewed as a
degenerate, from a resource perspective, form of linear logic.

Multisets and Petri nets both capture the idea that the nodes of an
attack tree capture both the attack action and the state -- the
resource -- of the system being analyzed. As it turns out, linear
logic has been shown to be a logical foundation for multisets
\cite{Tzouvaras:1998} and Petri Nets \cite{Brown:1991}.  Thus, linear
logic has the ability to model the state as well as attack actions of
the goals of an attack tree.  I propose that linear logic be used as
the logical foundation of attack trees.

This projects\footnote{This material is based upon work supported by
  the National Science Foundation CRII CISE Research Initiation grant,
  ``CRII:SHF: A New Foundation for Attack Trees Based on Monoidal
  Categories``, under Grant No. 1565557.} main goal is to determine
the suitability of linear logic as a foundation for attack trees.  In
this short paper I give an update on this project and introduce a new
logical foundation of attack trees. The type of attack trees
considered in this paper are attack trees with sequential composition
similar to Jhawar et al.~\cite{Jhawar:2015}.  Attack trees consist of
two layers: the logical layer or process tree, and the quantitative
layer.  One interesting aspect of my proposed foundation is that both
layers can be considered during reasoning about attack trees.

At the logical layer the base attacks of an attack tree will
correspond to atomic formulas in linear logic, and each branching node
of an attack tree will correspond to a binary operator in linear
logic.  Adding costs corresponds to annotating the atomic formulas
with some base cost, and then annotating the binary operators with a
cost computed from the costs of their respective left operand (left
subtree) and right operand (right subtree).  The most interesting
aspect of adding costs is that computing the costs at the branching
nodes is done during the construction of a derivation using the
inference rules of the logic.

The inference rules of linear logic provide a number of benefits when
constructing attack trees.  First, the inference rules will certify
that an attack tree is constructed correctly and all costs on
branching nodes will be computed from the costs of the left and right
subtrees.  On top of that the inference rules offer a means of proving
when two attack trees are equivalent. Leveraging the fact that
language of attack trees corresponds to a very simple fragment of
linear logic, e.g. linear implication is not needed, I conjecture
that proving equivalence of attack trees can be automated.  Thus, this
could be used in practice to certify the correctness of
transformations of attack trees maintaining the resource based
semantics.

\section{Attack Trees without Costs}
\label{sec:attack_trees_without_costs}
\input{attack-trees-output}
% section attack_trees_without_costs (end)

\section{Attack Trees with Costs}
\label{sec:attack_trees_with_costs}
\input{ll-attack-output}
% section attack_trees_with_costs (end)

\section{Conclusion and Future Work}
\label{sec:conclusion}
I introduced a new linear logic for reasoning about attack trees
called the Attack Tree Linear Logic (ATLL) with and without costs.
Attack trees are modeled as logical formulas and proving relationships
between attack trees corresponds to proving implications.  Adding
costs to ATLL results in a new indexed linear logic called Indexed
ATLL.  Then I showed how endowing implication with a relation on costs
can be used include the costs when reasoning about attack trees.

ATLL is just one part of this project, the following are some next
steps with respect to (Indexed) ATLL and other parts of the project:
\begin{itemize}
\item Define a term assignment for (Indexed) ATLL that can be used to
  define attack trees using a functional programming language.
\item Determine the applicability of automating reasoning on attack
  trees in (Indexed) ATLL using proof search.  
\item Finish studying the categorical model to which (Indexed) ATLL is
  based.
\item Finishing the development of a modular and stand alone IDE for
  attack tree in Javascript that can be used with various
  formalization of attack trees.  Hopefully, that the community will
  be able to make use of this interface.
\end{itemize}
% section conclusion (end)


\bibliographystyle{plain}
\bibliography{ref}

\appendix

\section*{Appendix}
\label{sec:appendix}

% section appendix (end)



\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

