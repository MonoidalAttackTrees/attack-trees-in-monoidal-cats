\documentclass{llncs}

\usepackage{amssymb,amsmath}
\usepackage{cmll}
\usepackage{stmaryrd}
\usepackage{todonotes}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[barr]{xy}
\usepackage{mdframed}

%% This renames Barr's \to to \mto.  This allows us to use \to for imp
%% and \mto for a inline morphism.
\let\mto\to
\let\to\relax
\newcommand{\to}{\rightarrow}

% Commands that are useful for writing about type theory and programming language design.
%% \newcommand{\case}[4]{\text{case}\ #1\ \text{of}\ #2\text{.}#3\text{,}#2\text{.}#4}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\normto}[0]{\rightsquigarrow^{!}}
\newcommand{\join}[0]{\downarrow}
\newcommand{\redto}[0]{\rightsquigarrow}
\newcommand{\nat}[0]{\mathbb{N}}
\newcommand{\fun}[2]{\lambda #1.#2}
\newcommand{\CRI}[0]{\text{CR-Norm}}
\newcommand{\CRII}[0]{\text{CR-Pres}}
\newcommand{\CRIII}[0]{\text{CR-Prog}}
\newcommand{\subexp}[0]{\sqsubseteq}
%% Must include \usepackage{mathrsfs} for this to work.
\newcommand{\powerset}[0]{\mathscr{P}}

\date{}

% Cat commands.
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\catop}[1]{\cat{#1}^{\mathsf{op}}}
\newcommand{\Hom}[3]{\mathsf{Hom}_{\cat{#1}}(#2,#3)}
\newcommand{\limp}[0]{\multimap}
\newcommand{\dial}[0]{\mathsf{Dial_3}(\mathsf{Sets})}
\newcommand{\dialSets}[1]{\mathsf{Dial_{#1}}(\mathsf{Sets})}
\newcommand{\dcSets}[1]{\mathsf{DC_{#1}}(\mathsf{Sets})}
\newcommand{\sets}[0]{\mathsf{Sets}}
\newcommand{\obj}[1]{\mathsf{Obj}(#1)}
\newcommand{\mor}[1]{\mathsf{Mor(#1)}}
\newcommand{\id}[0]{\mathsf{id}}
\newcommand{\lett}[0]{\mathsf{let}\,}
\newcommand{\inn}[0]{\,\mathsf{in}\,}
\newcommand{\cur}[1]{\mathsf{cur}(#1)}
\newcommand{\curi}[1]{\mathsf{cur}^{-1}(#1)}

\newenvironment{changemargin}[2]{%
  \begin{list}{}{%
    \setlength{\topsep}{0pt}%
    \setlength{\leftmargin}{#1}%
    \setlength{\rightmargin}{#2}%
    \setlength{\listparindent}{\parindent}%
    \setlength{\itemindent}{\parindent}%
    \setlength{\parsep}{\parskip}%
  }%
  \item[]}{\end{list}}

%% % Theorems
%% \newtheorem{theorem}{Theorem}
%% \newtheorem{lemma}[theorem]{Lemma}
%% \newtheorem{fact}[theorem]{Fact}
%% \newtheorem{corollary}[theorem]{Corollary}
%% \newtheorem{definition}[theorem]{Definition}
%% \newtheorem{remark}[theorem]{Remark}
%% \newtheorem{proposition}[theorem]{Proposition}
%% \newtheorem{notn}[theorem]{Notation}
%% \newtheorem{observation}[theorem]{Observation}

%% Ott
\input{atrees-ott}
\input{ll-attack-ott}
\input{oll-ott}
\renewcommand{\LLAdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\LLAdrulename{#4}}}
\renewcommand{\LLAdrulename}[1]{#1}
\renewcommand{\LLAdruleTXXvarName}{\text{id}_{\odot}}
\renewcommand{\LLAdruleTXXvarCName}{\text{id}_{\rhd}}
\renewcommand{\LLAdruleTXXparaName}{\odot}
\renewcommand{\LLAdruleTXXseqName}{\rhd}
\renewcommand{\LLAdruleTXXchoiceName}{\sqcup}

\renewcommand{\LLAdruleEXXvarName}{\text{id}_{\odot}}
\renewcommand{\LLAdruleEXXvarCName}{\text{id}_{\rhd}}
\renewcommand{\LLAdruleEXXchoiceContName}{\text{cont}_\sqcup}
\renewcommand{\LLAdruleEXXchoiceSymName}{\text{sym}_\sqcup}
\renewcommand{\LLAdruleEXXchoiceAssocName}{\text{assoc}_\sqcup}
\renewcommand{\LLAdruleEXXdistParaName}{\text{dis}_\odot}
\renewcommand{\LLAdruleEXXdistSeqName}{\text{dis}_\rhd}
\renewcommand{\LLAdruleEXXparaIName}{\odot_I}
\renewcommand{\LLAdruleEXXparaEName}{\odot_E}
\renewcommand{\LLAdruleEXXseqIName}{\rhd_I}
\renewcommand{\LLAdruleEXXseqEName}{\rhd_E}
\renewcommand{\LLAdruleEXXexName}{\text{sym}_\odot}
\renewcommand{\LLAdruleEXXchoiceName}{\sqcup}
\renewcommand{\LLAdruleEXXimpIName}{\multimap_I}
\renewcommand{\LLAdruleEXXimpEName}{\multimap_E}

\renewcommand{\ATLLdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\ATLLdrulename{#4}}}
\renewcommand{\ATLLdrulename}[1]{#1}
\renewcommand{\ATLLdruleTXXvarName}{\text{id}_{\odot}}
\renewcommand{\ATLLdruleTXXvarCName}{\text{id}_{\rhd}}
\renewcommand{\ATLLdruleTXXparaName}{\odot}
\renewcommand{\ATLLdruleTXXseqName}{\rhd}
\renewcommand{\ATLLdruleTXXchoiceName}{\sqcup}

\renewcommand{\ATLLdruleEXXvarName}{\text{id}_{\odot}}
\renewcommand{\ATLLdruleEXXvarCName}{\text{id}_{\rhd}}
\renewcommand{\ATLLdruleEXXchoiceContName}{\text{cont}_\sqcup}
\renewcommand{\ATLLdruleEXXchoiceSymName}{\text{sym}_\sqcup}
\renewcommand{\ATLLdruleEXXchoiceAssocName}{\text{assoc}_\sqcup}
\renewcommand{\ATLLdruleEXXdistParaName}{\text{dis}_\odot}
\renewcommand{\ATLLdruleEXXdistSeqName}{\text{dis}_\rhd}
\renewcommand{\ATLLdruleEXXparaIName}{\odot_I}
\renewcommand{\ATLLdruleEXXparaEName}{\odot_E}
\renewcommand{\ATLLdruleEXXseqIName}{\rhd_I}
\renewcommand{\ATLLdruleEXXseqEName}{\rhd_E}
\renewcommand{\ATLLdruleEXXexName}{\text{sym}_\odot}
\renewcommand{\ATLLdruleEXXchoiceName}{\sqcup}
\renewcommand{\ATLLdruleEXXimpIName}{\multimap_I}
\renewcommand{\ATLLdruleEXXimpEName}{\multimap_E}
\renewcommand{\ATLLdruleEXXweakSName}{\text{wk}_\odot}
\renewcommand{\ATLLdruleEXXweakPName}{\text{wk}_\rhd}

\begin{document}

%% \conferenceinfo{PLAS '16}{October 24, 2016, Vienna, Austria}
%% \copyrightyear{2016}
%% \copyrightdata{}
%% \copyrightdoi{}
%% \titlebanner{}

\title{A New Foundation of Attack Trees in Linear Logic}

\author{Harley Eades III}
\institute{Computer Science\\Augusta University \\ \href{mailto:heades@augusta.edu}{harley.eades@gmail.com}}

\maketitle 

\begin{abstract}
  In this short paper I provide an update on an ongoing research
  project investigating founding attack trees in the resource
  conscious theory called linear logic.  I introduce a new linear
  logic called the Attack Tree Linear Logic (ATLL) which models attack
  trees as formulas and uses implication to reason about attack trees.
  I then introduce a new generalization of Bucciarelli and Ehrhard’s
  indexed linear logic to obtain Indexed ATLL which adds costs to
  attack trees.  The most interesting aspect of Indexed ATLL is that
  implication is endowed with a relation for taking into consideration
  the costs while reasoning about attack trees.
\end{abstract}

\section{Introduction}
\label{sec:introduction}
%% the problem?
What is a mathematical model of attack trees?  There have been
numerous proposed answers to this question.  Some examples are
propositional logic, multisets, directed acyclic graphs, source sink
graphs (or parallel-series pomsets), Petri nets, and Markov processes.
Is there a unifying foundation in common to each of these proposed
models?  Furthermore, can this unifying foundation be used to further
the field of attack trees and build new tools for conducting threat
analysis?

The answer to the first question is positive, but the answer to the
second question is open.  Each of the proposed models listed above
have something in common.  They can all be modeled in some form of a
symmetric monoidal category
\cite{Tzouvaras:1998,Brown:1991,Fiore:2013,FrancescoAlbasini2010}.
That is all well and good, but what can we gain from monoidal
categories?

Monoidal categories are a mathematical model of linear logic as
observed through the beautiful Curry-Howard-Lambek correspondence
\cite{Mellies:2009}.  In linear logic every hypothesis must be used
exactly once, and hence, if we view a hypothesis as a resource, then
this property can be stated as every resource must be consumed.  This
linearity property is achieved by removing the structural rules for
weakening and contraction from classical or intuitionistic logic.

Multisets and Petri nets both capture the idea that the nodes of an
attack tree consist of the attack action and the state -- the
resource -- of the system being analyzed. As it turns out, linear
logic has been shown to be a logical foundation for multisets
\cite{Tzouvaras:1998} and Petri Nets \cite{Brown:1991}.  Thus, linear
logic has the ability to model the state as well as attack actions of
the goals of an attack tree.  

In this short paper I give an update of an ongoing
project\footnote{This material is based upon work supported by the
  National Science Foundation CRII CISE Research Initiation grant,
  ``CRII:SHF: A New Foundation for Attack Trees Based on Monoidal
  Categories``, under Grant No. 1565557.} whose main goal is to
determine the suitability of linear logic as a foundation for attack
trees; the type of attack trees considered in this paper are attack
trees with sequential conjunction due to Jhawar et
al.~\cite{Jhawar:2015}.  I introduce a new logical foundation of
attack trees with and without costs in linear logic.

This new linear logic is called the Attack Tree Linear Logic (ATLL)
(Section~\ref{sec:attack_trees_without_costs}).  Attack trees are
modeled in ATLL as linear formulas where base attacks are atomic
formulas, and each branching node corresponds to a binary logical
connective. Then reasoning about attack trees corresponds to proving
implications between attack trees.  In fact, every equation of attack
trees from Jhawar et al.'s work on attack trees with sequential
conjunction \cite{Jhawar:2015} can be proven as an implication in
ATLL.  In addition, implication can be used to prove subattack tree
relationships between attack trees.

Using a generalization of Bucciarelli and Ehrhard’s~\cite{?} indexed
linear logic I extend ATLL with costs.  I call this extension Indexed
ATLL (Section~\ref{sec:attack_trees_with_costs}).  In this system
every base attack is annotated with a cost, and every branching node
is annotated with a binary operation used for computing the cost at
that node.  Then implication is annotated with a binary relation on
costs.  This new binary relation is used to insure that the costs of
two trees are related when proving implications between attack trees.
Thus, one can prove facts about attack trees in ATLL that require one
to reason about both the tree structure as well quantitative data in
the tree simultaneously.

\section{Attack Trees without Costs}
\label{sec:attack_trees_without_costs}
\input{attack-trees-output}
% section attack_trees_without_costs (end)

\section{Attack Trees with Costs}
\label{sec:attack_trees_with_costs}
\input{ll-attack-output}
% section attack_trees_with_costs (end)

\section{Conclusion and Future Work}
\label{sec:conclusion}
I introduced a new linear logic for reasoning about attack trees
called the Attack Tree Linear Logic (ATLL) with and without costs.
Attack trees are modeled as logical formulas and proving relationships
between attack trees corresponds to proving implications.  Adding
costs to ATLL results in a new indexed linear logic called Indexed
ATLL.  Then I showed how endowing implication with a relation on costs
can be used to include the costs when reasoning about attack trees.

ATLL is just one part of this project, the following are some next
steps with respect to (Indexed) ATLL and other parts of the project:
\begin{itemize}
\item Define a term assignment for (Indexed) ATLL that can be used to
  define attack trees using a functional programming language.
\item Determine the applicability of automating reasoning on attack
  trees in (Indexed) ATLL using proof search.  
\item Finish studying the categorical model to which (Indexed) ATLL is
  based.
\item Finishing the development of a modular and stand alone IDE for
  attack tree in Javascript that can be used with various
  formalizations of attack trees.  Hopefully, that the community will
  be able to make use of this interface.
\item Develop the concrete implementation, called Lina, of (Indexed)
  ATLL with automation.
\end{itemize}
% section conclusion (end)


\bibliographystyle{plain}
\bibliography{ref}

\appendix

\section*{Appendix}
\label{sec:appendix}

% section appendix (end)



\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

