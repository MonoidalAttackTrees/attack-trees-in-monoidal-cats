% The full Ott spec of Simply Typed Grady.

embed
  {{tex-preamble \usepackage{cmll}
                 \usepackage{relsize} }}

metavar costvar, c ::=
metavar termvar, x, y , z, f ::=
metavar baseAttackVar, b ::=
indexvar index, i , j, k ::=

grammar
  A,B :: 'A_' ::=
    | b           :: :: Base
    | A (x) B :: :: Para
    {{tex [[A]] \otimes [[B]] }}
    | A -o B  :: :: Limp    

  G {{ tex \Gamma }}, D {{tex \Delta }} :: G_ ::=                 
    | .                   ::   :: emptyCtx     
    {{tex \cdot }}
    | A                   ::   :: vn           
    | G , G'              ::   :: append       
    | ( G )               :: M :: parens

  terminals :: 'terminals_' ::=
    | (.) :: :: Para
    {{tex \odot}}
    | > :: :: Seq
    {{tex \rhd}}
    | + :: :: Choice
    {{tex \sqcup }}
    |  ->                 ::   :: arrow
    {{tex \rightarrow }}
    |  <-                 ::   :: arrow2
    {{tex \leftarrow }}
    |  -o                 ::   :: arrow3
    {{tex \multimap }}    
    | |-                  ::   :: turnstile
    {{tex \vdash }}
    | |~                  ::   :: ndash
    {{tex \not \vdash }}    
    | succ                ::   :: succ
    {{tex \mathsf{succ} }}
    | ~                   ::   :: cons
    {{tex \sim }}
    | ~U                  ::   :: conv
    {{tex \sim_U }}    
    | elem                ::   :: elem
    {{tex \in }}
    | ~>                  ::   :: red
    {{tex \rightsquigarrow }}
    | box        :: :: box
    {{tex \mathsf{box} }}
    | unbox        :: :: unbox
    {{tex \mathsf{unbox} }}
    | fst        :: :: fst
    {{tex \mathsf{fst} }}
    | snd        :: :: snd
    {{tex \mathsf{snd} }}                

  formula :: 'formula_' ::=
    | judgement           ::   :: judgement
    | formula1 && formula2 ::  :: Quad
    {{tex [[formula1]] \quad [[formula2]] }}
    | ( formula )         :: S :: parens
    {{tex [[formula]] }}
    

defns
  Typing :: '' ::=

defn
 G ; D |- A :: :: type :: 'T_'    
 {{tex [[G]];[[D]] \vdash [[A]] }} by
    
 ------------- :: var
 .;(b,c) |-c b

 ------------- :: varC
 (b,c);. |-c b

 G1;D1 |-c1 T1  && G2;D2 |-c2 T2
 -------------------------------------- :: para
 G1,G2;D1,D2 |-(.)op(c1,c2) T1 (.)op T2

 G1;D1 |-c1 T1  && G2;D2 |-c2 T2
 -------------------------------------- :: seq
 G1,G2;D1,D2 |- >op(c1,c2) T1 >op T2

defn
 I ; P |- C E :: :: eq :: 'E_'    
 {{tex [[I]];[[P]] \vdash_{[[C]]} [[E]] }} by

 ------------- :: var
 .;(E,c) |-c E
 
 ------------- :: varC
 (E,c);. |-c E

 I1;P1 |-c1 E1  && I2;P2 |-c2 E2
 -------------------------------------- :: paraI
 I1,I2;P1,P2 |-(.)op(c1,c2) E1 (.)op E2

 I2;P1 |-(.)op(c1,c2) E1 (.)op E2 && I1,(E1,c1),(E2,c2),I3;P2 |-c3 E3
 -------------------------------------------------------------------- :: paraE
 I1,I2,I3;P1,P2 |-c3 E3

 I1;P1 |-c1 E1  && I2;P2 |-c2 E2
 -------------------------------------- :: seqI
 I1,I2;P1,P2 |- >op(c1,c2) E1 >op E2

 I1;P2 |- >op(c1,c2) E1 >op E2 && I2;P1,(E1,c1),(E2,c2),P3 |-c3 E3
 ----------------------------------------------------------------- :: seqE
 I1,I2;P1,P2,P3 |-c3 E3

 I1,(E1,c1),(E2,c2),I2;P |-c E
 ----------------------------- :: ex
 I1,(E2,c2),(E1,c1),I2;P |-c E

 I;P,(E1,c1) |-c2 E2 && ->op(c1,c2)
 ----------------------------------- :: impRI
 I;P |-c2 E1 ->op(c1,-) E2

 I1;P1 |-c2 E1 ->op(c1,-) E2 && I2;P2 |-c1 E1
 ---------------------------------------------- :: impRE
 I1,I2;P1,P2 |-c2 E2

 I;(E1,c1),P |-c2 E2 && <-op(c1,c2)
 ---------------------------------- :: impLI
 I;P |- c2 E2 <-op(c1,-) E1

 I1;P1 |- c2 E2 <-op(c1,-) E1 && I2;P2 |-c1 E1
 ---------------------------------------------- :: impLE
 I1,I2;P1,P2 |-c2 E2

 I,(E1,c1);P |-c2 E2 && -oop(c1,c2)
 ---------------------------------- :: impI
 I;P |- -oop(c1,c2) E1 -o E2

 I1;P1 |-c2 E1 -oop(c1,-) E2 && I2;P2 |-c1 E1
 ---------------------------------------------- :: impE
 I1,I2;P1,P2 |-c2 E2 